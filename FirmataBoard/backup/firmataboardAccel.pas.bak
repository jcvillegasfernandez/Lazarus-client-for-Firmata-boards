unit firmataboard;

{$mode objfpc}{$H+}

interface

uses
{$IFDEF LINUX}
  Classes,
{$IFDEF UseCThreads}
  cthreads,
{$ENDIF}
{$ELSE}
  Windows, Classes, //registry,
{$ENDIF}
 ExtCtrls, sysUtils, forms, firmataconstants,
  StdCtrls, dialogs,  LResources, LclIntf;

 type
  // Digital Pin register type

  TCapability = record
    Mode: Byte;         // pin mode
    Resolution: Byte;   // Bits of resolution
  end;

  TCapabilities = array of TCapability;

  TPin = record
       Busy: TComponent;      // if TComponent is not nil then is assigned to a module
       ActualMode: Byte;    // pin mode 1-digital, 2-analog, etc
       AnalogMap: Byte;     // analog pin mapping
       Value: integer;     // Current value of the pin. when pin is digital and set to output it will be
                           // HIGH or LOW. If the pin is an analog pin it will be an numeric value
       Capabilities: TCapabilities; // supported modes and resolutions
       State: integer;  // For output pins this is the last value written to the pin on the board, for digital input
                     // it's the status of the pullup resistor (1 = pullup enabled, 0 = pullup disabled)
  end;

  TPins = Array of TPin;   // array of pins

  TFirmataTypes = (StandardFirmata, StandardFirmataPlus, ConfigurableFirmata, FirmataPlus);

  TOnBeforeOpen = procedure(sender: TObject) of Object;
  TOnAfterClose = procedure(sender: TObject) of Object;
  TOnSendDataToDevice = procedure(sender: TObject; str: string) of Object;
  TOnGetDataFromDevice = function(sender: TObject): integer of object;
  TOnDeviceDataAvailable = function(sender: TObject): Boolean of object;
  TOnError = procedure(sender: TObject; Error: integer; TextError: string; Afected: integer) of Object;
  TOnCapabilities = procedure(sender: TObject) of Object;
  TOnFirmataReady = procedure(sender: TObject) of Object;
  TOnFirmataData = procedure(sender: TObject; Command: Byte; Data: string) of object;
  TOnPinValueChange = procedure(sender: TObject; Pin: Byte; Value: integer) of object;
  TOnPinStateChange = procedure(sender: TObject; Pin: Byte; Mode: Byte; State: integer) of object;
  TOnExtendedSysex = procedure(sender: TObject; ID0: byte; ID1: byte; Data: String) of Object;

  TOnEnabled = procedure(sender: TObject) of Object;
  TOnDisabled = procedure(sender: TObject) of Object;

  TOnTaskError = procedure(sender: TObject; TaskID: byte; Time: integer; Length: integer; Place: integer; TaskData: String) of object;
  TOnQueryAllTask = procedure(sender: TObject; TaskIDs: array of byte) of object;
  TOnQueryTask = procedure(sender: TObject; TaskID: byte; Time: integer; Length: integer; Place: integer; TaskData: String) of object;
  TOnOneWireSearch = procedure(sender: TObject; Pin: Byte; DeviceIDs: array of string) of Object;
  TOnOneWireAlarm = procedure(sender: TObject; Pin: Byte; AlarmIDs: array of string) of Object;
  TOnOneWireData = procedure(sender: TObject; Pin: Byte; Data: string) of Object;
  TOnI2CData = procedure(sender: TObject; Slave: Byte; Reg_Number: Byte; Data: string) of Object;

  TFirmataBoard = class;

  TFirmataReadThread = class(TThread)
   public
     MustDie: boolean;
     Owner: TFirmataBoard;
   protected
     procedure CallEvent;
     procedure Execute; override;
   published
     property Terminated;
   end;

  TFirmataTasks = class;
  TFirmataOneWire = class;
  TFirmataI2C = class;

  TFirmataBoard = class (TComponent)
    private
      FReadThread: TFirmataReadThread;
      FLastError: integer;
      FEnabled: Boolean;
      FStarting: Boolean;
      FGotCapabilities: Boolean;
      FGotFirmware: Boolean;
      FGotVersion: Boolean;
      FSamplingInterval: integer;

      FOnError: TOnError;
      FOnFirmataData: TOnFirmataData; // only when there are firmata data and no other event
      FOnPinValueChange: TOnPinValueChange;
      FOnPinStateChange:   TOnPinStateChange;
      FOnBeforeOpen: TOnBeforeOpen;
      FOnAfterClose: TOnAfterClose;

      FOnSendDataToDevice: TOnSendDataToDevice;
      FOnGetDataFromDevice: TOnGetDataFromDevice;
      FOnDeviceDataAvailable: TOnDeviceDataAvailable;
      FOnExtendedSysex: TOnExtendedSysex;

      {procedure setFFirmataOnewire(ModuleOnewire: TFirmataOnewire); }
     { procedure setFFirmataI2C(ModuleI2C: TFirmataI2C);
      procedure setFFirmataAccelStepper(ModuleAccelStepper: TFirmataAccelStepper);
      procedure setFFirmataSerial(ModuleSerial: TFirmataSerial);}
    private
      FPins: TPins;  // array of Pins capabilities, values, etc.
      FPinsNumber: integer;  // Number of total pins
      FAnalogPinsNumber: integer;  //number of analog pins
      FPinModesMap: array[0..14] of byte;
      FFirmataType: TFirmataTypes;
      FFirmataVersion: array [0..1] of byte;
      FFirmataStringFirmware: string;
      FFirmataFirmware: array [0..1] of byte;

      FEndCommand: Boolean;
      FOnCapabilities: TOnCapabilities;
      FOnFirmataReady: TOnFirmataReady;
      FInitTime: QWord;
      FTimeEnd: QWord;
      FStartedTime: QWord;
      FFirmataTasks:   TFirmataTasks;
      FFirmataOnewire: TFirmataOneWire;
      FFirmataI2C: TFirmataI2C;
      // Firmata Modules
      {
      FFirmataAccelStepper: TFirmataAccelStepper;
      FFirmataSerial: TFirmataSerial; }

      procedure setEnabled(State: Boolean);
      procedure initPinsArrays;

      function GetPin(Index: Integer): TPin;
      procedure SetSamplingInterval(Interval: integer);

      procedure ComException(Error: integer; TextError: string; Afected: integer=-1);
    public
      function GetNextByte: Byte;
      procedure GetFirmataCommand(Sender: TObject);

      constructor Create(AOwner: TComponent); override;
      destructor Destroy; override;

      // Firmata comands
      // All firmata functions for commands return the string command sent, they have a write parameter, if write is True the data is sent to the external device
      // if write is false then is not sent to device
      //
      // Pin functions
      function BoardReset(write: Boolean=true): string;
      function askVersion(write: Boolean=true): string;
      function askFirmware(write: Boolean=true): string;
      function askBoardCapabilities(write: Boolean=true): string;
      function SendSamplingInterval(Interval: integer; write: Boolean=true): string;

      // pins general
      function askPinState(Pin: byte; write: Boolean=true): string;
      function SetPinMode(Pin: byte; Mode: Byte; write: Boolean=true): string; // if write true then send bytes to device
      // digital ports
      function DigitalWritePort(Port: byte; Value: integer; PortPins: byte; write: Boolean=true): string;
      function DigitalWritePort(Port: byte; Value: integer; write: Boolean=true): string; overload;
      function DigitalReport(port: byte; enabled: boolean; PortPins: byte; write: Boolean=true): string;
      function DigitalReport(port: byte; enabled: boolean; write: Boolean=true): string; overload;
      // digital pins
      function DigitalWrite(Pin: byte; Value: Byte; write: Boolean=true): string;  //Same as SetDigitalPinValue
      function SetDigitalPinValue(Pin: byte; Value: Byte; write: Boolean=true): string;   // only set value for one digital pin
      // Analog pins
      function AnalogWrite(AnalogPin: byte; Value: integer; write: Boolean=true): string;
      function AnalogWriteExtended(Pin: Byte; Value: integer; write: Boolean=true): string;  // same as SendExtendedAnalog
      function AnalogReport(AnalogPin: byte; enabled: boolean; write: Boolean=true): string;
      function SendAnalogMessage(AnalogPin: byte; Value: integer; write: Boolean=true): string;  // same as AnalogWrite
      function SendExtendedAnalog(Pin: Byte; Value: integer; write: Boolean=true): string; // analog write (PWM, Servo, etc) to any pin

      // send commands
      function SendCommand(Data: string; write: Boolean=True): string;
      function SendSysEx(data7bit: string; write: Boolean=true): string;

      // Getting firmata data
      procedure GetDigitalMessage(Command: byte; PortPins: byte);  // get digital values max for 13 pins at same time
      procedure GetDigitalMessage(Command: byte); overload;  // get digital 8 bits in port
      procedure GetAnalogMessage(Command: byte);
      procedure GetSysExCommandData(Command: Byte);

      procedure Reset;  // Reset CustomFirmata
      procedure Open;
      procedure Close;

      // util functions
      function ReversePinModesMap(Mode: byte): byte;
      function GetPinFromAnalogPin(AnalogPin: byte): Byte;
      function PinModesText(Mode: byte): string;
      function Encode1ByteCharTo2(Data1Byte: string): string;
      function Decode2BytesCharTo1(Data2bytes: string): string;
      function StrToHex(const Buffer: string): string;   // Return a hex string from a byte string
      function StrToHexSep(const Value: string): string;  // Return a separated hex string from a byte string
      function Decode7To8bit(Data7bit: string): String;
      function Encode8To7Bit(Data8bit:string): string;
      function IntToStrByte(Value: Integer; size: Byte): String;       // converts a value into a byte string low byte first
      function StrByteToInt(DataString: String): integer;        // converts a string of bytes, low byte first, into a int value
      function CheckCapability(Pin: byte; Mode: Byte): Boolean;
      function GetPinResolution(Pin: Byte; Mode: Byte): Integer;  // get pin resolution in a mode

      procedure Info;
      procedure printPinInfo(Memo: TMemo);

      property Pins[Index:Integer]: TPin read GetPin;
      property FirmataTasks: TFirmataTasks read FFirmataTasks write FFirmataTasks;
      property FirmataOnewire: TFirmataOneWire read FFirmataOnewire write FFirmataOnewire;

      property FirmataI2C: TFirmataI2C read FFirmataI2C write FFirmataI2C;
//      property FirmataAccelStepper: TFirmataAccelStepper write setFFirmataAccelStepper;
//      property FirmataSerial: TFirmataSerial write setFFirmataSerial; }

    published
      property SamplingInterval: integer read FSamplingInterval write SetSamplingInterval;
      property LastError: integer read FLastError write FLastError;
      property PinsNumber: integer read FPinsNumber;
      property AnalogPinsNumber: integer read FAnalogPinsNumber;
      property TimeStarting: Qword read FTimeEnd;  // max time to wait starting
      property TimeToStart: Qword read FStartedTime;  // time spend starting firmata
      property FirmataFirmware: string read FFirmataStringFirmware;
      property Enabled: Boolean read FEnabled write SetEnabled;
      property FirmataType: TFirmataTypes read FFirmataType ;
      property OnBeforeOpen: TOnBeforeOpen read FOnBeforeOpen write FOnBeforeOpen;
      property OnAfterClose: TOnAfterClose read FOnAfterClose write FOnAfterClose;
      property OnCapabilities: TOnCapabilities read FOnCapabilities write FOnCapabilities;
      property OnFirmataReady: TOnFirmataReady read FOnFirmataReady write FOnFirmataReady;
      property OnSendDataToDevice: TOnSendDataToDevice read FOnSendDataToDevice write FOnSendDataToDevice;
      property OnGetDataFromDevice: TOnGetDataFromDevice read FOnGetDataFromDevice write FOnGetDataFromDevice;
      property OnDeviceDataAvailable: TOnDeviceDataAvailable read FOnDeviceDataAvailable write FOnDeviceDataAvailable;
      property OnError: TOnError read FOnError write FOnError;
      property OnFirmataData: TOnFirmataData read FOnFirmataData write FOnFirmataData;
      property OnPinValueChange: TOnPinValueChange read FOnPinValueChange write FOnPinValueChange;
      property OnPinStateChange: TOnPinStateChange read FOnPinStateChange write FOnPinStateChange;
  end;

  TTask = record
    ID: byte;    // Task number
    Data: string;    // Task Data to execute
    Size: uint16;    // Data Size
  end;

  TTasks = array of TTask;

  TFirmataTasks = class (TComponent)
    private
      FFirmataBoard: TFirmataBoard;
      FEnabled: Boolean;
      FTasks: TTasks;

      FOnEnabled: TOnEnabled;
      FOnDisabled: TOnDisabled;

      FOnTaskError: TOnTaskError;
      FOnQueryAllTask: TOnQueryAllTask;
      FOnQueryTask : TOnQueryTask;

      procedure setFirmataBoard(Board: TFirmataBoard);
      procedure setEnabled(State: Boolean);
    public
      procedure GetFirmataCommand(Sender: TObject; Command: Byte);
      function GetNextByte: Byte;
      constructor Create(AOwner: TComponent); override;
      destructor Destroy; override;

      // Firmata comands
      // All firmata functions for commands return the string command sent, they have a write parameter, if write is True the data is sent to the external device
      // if write is false then is not sent to device
      // Scheduler commands
      function CreateTask(TaskID: Byte; Length: integer; write: Boolean=true): string;
      function DeleteTask(TaskID: Byte; write: Boolean=true): string;
      function AddToTask(TaskID: Byte; Data7Bit: String; write: Boolean=true): string;
      function DelayTask(Delay: integer; write: Boolean=true): string;
      function ScheduleTask(TaskID: Byte; Time: integer; write: Boolean=true): string;
      function QueryAllTasks(write: Boolean=true): string;
      function QueryTask(TaskID: Byte; write: Boolean=true): string;
      function SchedulerReset(write: Boolean=true): string;

    published
      property FirmataBoard: TFirmataBoard read FFirmataBoard write setFirmataBoard;
      property Enabled: Boolean read FEnabled write SetEnabled;
      property OnEnabled: TOnEnabled read FOnEnabled write FOnEnabled;
      property OnDisabled: TOnDisabled read FOnDisabled write FOnDisabled;
      property OnTaskError: TOnTaskError read FOnTaskError write FOnTaskError;
      property OnQueryAllTask: TOnQueryAllTask read FOnQueryAllTask write FOnQueryAllTask;
      property OnQueryTask: TOnQueryTask read FOnQueryTask write FOnQueryTask;
  end;

  TFirmataOneWire = class (TComponent)
    private
      FFirmataBoard: TFirmataBoard;
      FEnabled: Boolean;
      FOneWirePin: Byte;
      FParasitisticPower: Boolean;

      FOnEnabled: TOnEnabled;
      FOnDisabled: TOnDisabled;
      FOnOneWireData:  TOnOneWireData;
      FOnOneWireSearch: TOnOneWireSearch;
      FOnOneWireAlarm: TOnOneWireAlarm;

      procedure setOneWirePin(Pin: Byte);
      procedure setFirmataBoard(Board: TFirmataBoard);
      procedure setEnabled(State: Boolean);
      function InternalCRC8(Buffer: String): Byte;
      function InternalCRC16(Buffer: String): uint16;
    public
      procedure GetFirmataCommand(Sender: TObject; Command: Byte);
      function GetNextByte: Byte;
      constructor Create(AOwner: TComponent); override;
      destructor Destroy; override;

      // Firmata comands
      // All firmata functions for commands return the string command sent, they have a write parameter, if write is True the data is sent to the external device
      // if write is false then is not sent to device
      // Onewire functions
      function OnewireConfig(Pin: Byte; ParasitisticPower: Boolean; write: Boolean=true): string;
      function OnewireSearch(Pin: Byte; write: Boolean=true): string;
      function OnewireAlarmSearch(Pin: Byte; write: Boolean=true): string;
      function OnewireReset(Pin: Byte; write: Boolean=true): string;
      function OnewireSkip(Pin: Byte; write: Boolean=true): string;
      function OnewireSelect(Pin: Byte; Device: string; write: Boolean=true): string;
      function OnewireResetAndSelect(Pin: Byte; Device: string; write: Boolean=true): string;
      function OnewireRead(Pin: Byte; BytestoRead: uint16; Correlation: uint16; write: Boolean=true): string;
      function OnewireDelay(Pin: Byte; Delay: integer; write: Boolean=true): string;
      function OnewireWrite(Pin: Byte; Data: string; write: Boolean=true): string;
      function OnewireWrite(Pin: Byte; Delay: integer; Data: string; write: Boolean=true): string; overload;
      function OnewireWriteAndRead(Pin: Byte; BytestoRead: uint16; Correlation: uint16; Data: string; write: Boolean=true): string;
      function OnewireWriteAndRead(Pin: Byte; BytestoRead: uint16; Correlation: uint16;
                                       Delay: integer; Data: string; write: Boolean=true): string; overload;
      function SendOnewireCommands(Command: Byte; Pin: Byte; Device: String; numBytesToRead: uint16; correlationId: uint16;
                                       delay: integer; dataToWrite: String; write: Boolean=true): string;
      // util functions
      function CheckCRC8(Buffer: String): Boolean; // check crc last byte is CRC8 to check
      function CheckCRC16(Buffer: String): Boolean;  // check crc last 2 bytes are CRC16 to check
    published
      property OneWirePin: Byte read FOneWirePin write setOneWirePin;
      property FirmataBoard: TFirmataBoard read FFirmataBoard write setFirmataBoard;
      property Enabled: Boolean read FEnabled write SetEnabled;
      property OnEnabled: TOnEnabled read FOnEnabled write FOnEnabled;
      property OnDisabled: TOnDisabled read FOnDisabled write FOnDisabled;
      property OnOneWireData: TOnOneWireData read FOnOneWireData write FOnOneWireData;
      property OnOneWireSearch: TOnOneWireSearch read FOnOneWireSearch write FOnOneWireSearch;
      property OnOneWireAlarm: TOnOneWireAlarm read FOnOneWireAlarm write FOnOneWireAlarm;
      property ParasitisticPower: Boolean read FParasitisticPower write FParasitisticPower;
  end;

  TFirmataI2C = class (TComponent)
    private
      FFirmataBoard: TFirmataBoard;
      FEnabled: Boolean;

      FI2Cconfig: string;
      FDelay: byte;
      FI2CQueries: Byte;
      FSDApin: Byte;
      FSCLpin: Byte;

      FOnEnabled: TOnEnabled;
      FOnDisabled: TOnDisabled;
      FOnI2CData: TOnI2CData;

      procedure setSDAPin(SDApin: Byte); // set SDA pin
      procedure setSCLPin(SCLpin: Byte); // set SCL pin
      procedure setFirmataBoard(Board: TFirmataBoard);
      procedure setEnabled(State: Boolean);

    public
      procedure GetFirmataCommand(Sender: TObject);
      function GetNextByte: Byte;
      constructor Create(AOwner: TComponent); override;
      destructor Destroy; override;

      // Firmata comands
      // All firmata functions for commands return the string command sent, they have a write parameter, if write is True the data is sent to the external device
      // if write is false then is not sent to device
      // I2c commands
      function i2cConfig(write: Boolean=true): string; overload;  // delay
      function i2cConfig(Delay: byte; write: Boolean=True): string; overload;  // delay
      function i2cConfig(delay: byte; data: string; write: Boolean=true): string; overload;
      function i2cConfig(data: string; write: Boolean=true): string; overload;
      function i2cRequest(Slave: word; command: byte; data: string; restart: Boolean=false; mode10bit: boolean=false; write: Boolean=True): string;
      function i2cWrite(Slave: Byte; Address: integer; AddressSize: Byte; Data: String; restart: Boolean=false; write: Boolean=True): string;
      function i2cRead(Slave: Byte; regID: integer; BytesToRead: byte; restart: Boolean=false; write: Boolean=true): string;
      function i2cRandomRead(Slave: Byte; Address: word; AddressSize: Byte; BytesToRead: byte; restart: Boolean=false; write: Boolean=True): string;
      function i2cReadContinuosly(Slave: Byte; RegID: integer; BytesToRead: byte; restart: Boolean=false; write: Boolean=true): string;
      function i2cStopReading(Slave: Byte; write: Boolean=true): string;
      // i2c 10 bits functions, not implemented yet on Firmata
      function i2cWrite10Bits(Slave: uint16; Address: integer; AddressSize: Byte; Data: String; restart: Boolean=false; write: Boolean=True): string;
      function i2cRead10bits(Slave: uint16; regID: integer; BytesToRead: byte; restart: Boolean=false; write: Boolean=true): string;
      function i2cRandomRead10bits(Slave: Byte; Address: word; AddressSize: Byte; BytesToRead: byte; restart: Boolean=false; write: Boolean=True): string;
      function i2cRead10bitsContinuosly(Slave: uint16; RegID: integer; BytesToRead: byte; restart: Boolean=false; write: Boolean=true): string;
      function i2cStopReading10Bits(Slave: uint16; write: Boolean=True): string;
      // util functions
      // not published
    published
      property SDApin: Byte read FSDApin write setSDAPin;
      property SCLpin: Byte read FSCLpin write setSCLPin;
      property Delay: Byte read FDelay write FDelay;
      property FirmataBoard: TFirmataBoard read FFirmataBoard write setFirmataBoard;
      property Enabled: Boolean read FEnabled write SetEnabled;
      property OnEnabled: TOnEnabled read FOnEnabled write FOnEnabled;
      property OnDisabled: TOnDisabled read FOnDisabled write FOnDisabled;
      property OnI2CData: TOnI2CData read FOnI2CData write FOnI2Cdata;
  end;

procedure Register;

implementation
uses
  LazarusPackageIntf;

procedure Register;
begin
  {$I firmataboard.lrs}
  RegisterComponents('Firmata', [TFirmataBoard, TFirmataTasks, TFirmataOneWire, TFirmataI2C]);
end;


procedure CloseApplication;
begin
  Application.Terminate; // cierra programa
  while not Application.Terminated do   // comprueba que realmente termina
    Application.ProcessMessages;
end;

{ TComPortReadThread }
procedure TFirmataReadThread.CallEvent;
begin
  if Assigned(owner.FOnDeviceDataAvailable) then
  begin
     if Owner.FOnDeviceDataAvailable(self) then  // must return true if dataavailable
       Owner.GetFirmataCommand(self)  // must be a new command
  end
  else
  begin
    Owner.ComException(26, 'CallEvent');  // now way to check available data
  end;
end;

procedure TFirmataReadThread.Execute;
begin
  try
    while not MustDie do
    begin
      Synchronize(@CallEvent);
    end;
  finally
    Terminate;
  end;

end;

{ TFirmataBoard }
constructor TFirmataBoard.Create(AOwner: TComponent);
begin
  inherited;

  FReadThread:=nil;
  FStarting:=False;
  FEndCommand:=true;
  FEnabled:=False;
  FOnBeforeOpen:=nil;
  FOnAfterClose:=nil;
  FOnFirmataReady:=nil;
  FOnSendDataToDevice:=nil;
  FOnGetDataFromDevice:=nil;
  FOnDeviceDataAvailable:=nil;
  FOnError:=nil;
  FOnFirmataData:=nil;
  FOnPinValueChange:=nil;
  FOnPinStateChange:=nil;
  FFirmataType:=StandardFirmata;   // default firmata
  FSamplingInterval:=19;  // 19 milisec default arduino sampling interval
  FPinsNumber:=0;
  FAnalogPinsNumber:=0;
  FGotCapabilities:=False;
  FGotFirmware:=False;
  FGotVersion:=False;
  FTimeEnd:=6000; // default max time to wait for firmata to start
  FStartedTime:=0;
  FFirmataTasks:=nil;
  FFirmataOnewire:=nil;
  FFirmataI2C:=nil;
//  FFirmataAccelStepper:=nil;
//  FFirmataSerial:=nil;
end;

destructor TFirmataBoard.Destroy();
begin
  // Unlink modules

  inherited Destroy;
end;

function TFirmataBoard.GetPin(Index: Integer): TPin;
begin
  if (Index < FPinsNumber) and (Index >= 0) then
     Result:=FPins[Index]
  else
     Result:=default(TPin);
end;

procedure TFirmataBoard.SetSamplingInterval(Interval: integer);
begin
  SendSamplingInterval(Interval);
end;

function TFirmataBoard.SendSamplingInterval(Interval: integer; write: Boolean=true): string;
begin
  if interval=FSamplingInterval then
    exit;
  FSamplingInterval:=Interval;
  // dont know if both bytes LSB and MSB are 7 or 8 bits
  Result:=SendSysEx(chr(SAMPLING_INTERVAL)+chr(Interval and $7F)+chr((Interval >> 7) and $7F), write);
end;

procedure TFirmataBoard.setEnabled(State: Boolean);
begin
  If FEnabled = State then
     exit;

  if State then
     Open
  else
     Close;
end;

procedure TFirmataBoard.Open;
begin
  if FEnabled then   //already open
     exit;

  initPinsArrays;

  FEndCommand:=true;
  FStarting:=True;
  FGotCapabilities:=False;
  FGotFirmware:=False;
  FGotVersion:=False;

  if Assigned(FOnBeforeOpen) then
     FOnBeforeOpen(self);

  if not Assigned(FOnSendDataToDevice) then
  begin
    comException(1, 'Open');
    close;
  end;
  if not Assigned(OnGetDataFromDevice) then
  begin
     comException(28, 'Open');
     close;
  end;
 if not Assigned(OnDeviceDataAvailable) then
  begin
     comException(26, 'Open');
     close
  end;

  // Launch Thread
  FReadThread := TFirmataReadThread.Create(true);
  FReadThread.Owner := Self;
  FReadThread.MustDie := false;
  //  ReadThread.Resume;   --> deprecated
  FReadThread.Start;

  // init time measure for starting firmata
  FInitTime:=TThread.GetTickCount64;  // milisec
end;

procedure TFirmataBoard.Close;
begin
  FEnabled:=False;

  // stop runnung thread
  if FReadThread <> nil then begin
    FReadThread.FreeOnTerminate:=false;
    FReadThread.MustDie:= true;

    while not FReadThread.Terminated do begin
      Application.ProcessMessages;
    end;

    FReadThread.Free;
    FReadThread:=nil;
  end;

  if Assigned(FOnAfterClose) then
    FOnAfterClose(self);
end;

procedure TFirmataBoard.Info;
var
  Firmatastring: string;
begin
  if FGotVersion and FGotFirmware then
  begin
    // ConfigurableFirmata sends Version, Firmware and analog pins values
    //      default pin mode is output low for digital pin, analog pins as input
    // StandardFirmata Board sends Version and Firmware, default digital pin mode is output low
    //      analog pins as input
    // StandardFirmataPlus firmware, default digital pin mode is output low
    //      analog pins as input
    // FirmataPlus sends Version, Firmware, default digital pin mode is output low
    //      analog pins as input changed some pin modes values

    //Configure pin modes mapping for the board
    Firmatastring:=LowerCase(LeftStr(FFirmataStringFirmware,Pos('.',FFirmataStringFirmware)-1));
    if FirmataString='standardfirmata' then
    begin
     { Pin modes mapping
      INPUT/OUTPUT/ANALOG/PWM/SERVO/SHIFT/I2C/ONEWIRE/STEPPER/ENCODER/SERIAL/PULLUP/TONE/SONAR/ IGNORE
      0    /     1/     2/  3/    4/    5/  6/      7/      8/      9/    10/    11/  12/   13/    127
      }
      FFirmataType:=StandardFirmata;
      // StandardFirmata Board sends Versión, then firmware
    end
    else if FirmataString='standardfirmataplus' then
    begin
      FFirmataType:=StandardFirmataPlus;
    end
    else if FirmataString='firmataplus' then
    begin
      FFirmataType:=FirmataPlus;
      { Pin modes mapping
      INPUT/OUTPUT/ANALOG/PWM/SERVO/SHIFT/I2C/ONEWIRE/STEPPER/ENCODER/SERIAL/PULLUP/TONE/SONAR/ IGNORE
      0    /     1/     2/  3/    4/    5/  6/      7/      8/      9/    10/    11/  12/   13/    127
      }
      FPinModesMap[10]:=$0C;
      FPinModesMap[11]:=$0D;
      FPinModesMap[12]:=$0A;
      FPinModesMap[13]:=$0B;
      //FPinModesMap[PIN_MODE_SERIAL]:=PIN_MODE_SERIAL_FP;
      //FPinModesMap[PIN_MODE_PULLUP]:=PIN_MODE_PULLUP_FP;
      //FPinModesMap[PIN_MODE_TONE]:=PIN_MODE_TONE;
      //FPinModesMap[PIN_MODE_SONAR]:=PIN_MODE_SONAR;
    end
    else if FirmataString='configurablefirmata' then
    begin
      // ConfigurableFirmata sends Version, Firmware and analog pins values
      // default pin mode is output for digital pin
      FFirmataType:=ConfigurableFirmata;
    end
    else  // none of them then defaults to StandardFirmata
    begin
      FFirmataType:=StandardFirmata;
    end;
  end
  else
  begin
    comException(2, 'Info');
    exit;
  end;
end;

function TFirmataBoard.askVersion(write: Boolean=true): string;
begin
  Result:=SendSysEx(chr(REPORT_VERSION), write);
end;

function TFirmataBoard.askFirmware(write: Boolean=true): string;
begin
  Result:=SendSysEx(chr(REPORT_FIRMWARE), write);
end;

function TFirmataBoard.askBoardCapabilities(write: Boolean=true): string;
begin
  Result:=SendSysEx(chr(CAPABILITY_QUERY), write);
end;

procedure TFirmataBoard.initPinsArrays;
var
  i: integer;
begin
  FPinsNumber:=0;
  FAnalogPinsNumber:=0;
  Setlength(FPins,0);

  // set default pin modes map StandardFirmata
  for i:=0 to length(FPinModesMap)-1 do
    FPinModesMap[i]:=i;

  FEndCommand:=True;
  FFirmataVersion[0]:=0;
  FFirmataVersion[1]:=0;
  FFirmataStringFirmware:='';
  FFirmataFirmware[0]:=0;
  FFirmataFirmware[1]:=0;
  FGotVersion:=False;
  FGotFirmware:=False;
  FGotCapabilities:=False;
end;

procedure TFirmataBoard.ComException(Error: integer; TextError: string; Afected: integer=-1);
var
  ErrorString: string;
begin
  FLastError:=Error;
  if Error < 1000 then  // recuperable error
    ErrorString:=Format('Error (%d); %s in %s',[Error, ErrorsArray[Error], TextError])
  else    // no recuperable error
    ErrorString:=Format('Error (%d); %s in %s',[Error, ErrorsArray[Error - 1000], TextError]);

  if Assigned(FOnError) then
     FOnError(self, Error, ErrorString, Afected);
  if Error > 1000 then // no recuperable error
  begin
    raise Exception.Create(ErrorString);
    CloseApplication;
  end;
end;

procedure TFirmataBoard.Reset;
begin
   BoardReset;
   Close;
   Open;
end;

//
// This is a weird function because of the problem with TThread, threads only run when the program is in idle state, out of a Event
//
function TFirmataBoard.GetNextByte: Byte;
var
  value: integer;
  TimeOut: QWord;
begin
  Value:=-1;
  TimeOut:=TThread.GetTickCount64;

  while true do
  begin
    if Assigned(FOnGetDataFromDevice) then
      Value:=FOnGetDataFromDevice(self);
    if Value <> -1 then
      break;
    if not FStarting and ((TThread.GetTickCount64 - TimeOut) > 2000) then  // time out reading a byte
    begin
      comException(31, 'GetNextByte');
      Close;
    end;
  end;
  Result:=Value;
   // Check if firmata has started to stop time out
   if FStarting then
   begin
     FStartedTime:=TThread.GetTickCount64-FInitTime;   // Get milisec ticks

     if FStartedTime > FTimeEnd then  // time out for firmata, default to 6 second
     begin
       comException(3, 'GetNextByte');
       FStarting:=False;
       Close;
    end;
  end;
end;

procedure TFirmataBoard.GetFirmataCommand(Sender: TObject);
var
  ReadByte: byte;
begin
  if FEndCommand then    // last command has finished
  begin
    FEndCommand:=False;  // Start a new command
    ReadByte:=GetNextByte;

    case ReadByte of
      START_SYSEX: begin  // 0xF0
        GetSysExCommandData(GetNextByte);
      end;
      {0  digital data, 0x90-0x9F, second nibble of byte 0 gives the port number (e.g. 0x92 is the third port, port 2)
      1  digital pins 0-6 bitmask
      2  digital pin 7-13 bitmask}
      $90 .. $9F: begin  // digital I/O message
          GetDigitalMessage(ReadByte);
      end;
      {0  analog pin, 0xE0-0xEF,
      1  analog least significant 7 bits
      2  analog most significant 7 bits}
      $E0 .. $EF: begin  // analog I/O message
          GetAnalogMessage(ReadByte);
      end;
      {0  version report header (0xF9)
      1  major version (0-127)
      2  minor version (0-127)}
      REPORT_VERSION: begin //
        FFirmataVersion[0]:=GetNextByte;
        FFirmataVersion[1]:=GetNextByte;
        FGotVersion:=true;
      end;
    end;
    FEndCommand:=True;
  end;
end;

procedure TFirmataBoard.GetSysExCommandData(Command: byte);
var
  ReadByte: Byte;
  Pin: byte;
  AnalogPin: byte;
  Value: integer;
  Mode: Byte;
  DataString: string;
  // exended sysex
  ID0: byte;
  ID1: byte;
begin
     DataString:='';
     case Command of
          { 0  START_SYSEX       (0xF0)
          1 EXTENDED_SYSEX       (0x00)
          2 EXTENTED_ID_0         byte0
          3 EXTENDED_ID_1         byte1
          ... PAYLOAD             nbytes
          N  END_SYSEX           (0xF7)}
          EXTENDED_SYSEX: begin // 0x00  not yet supported
             // TODO
             ID0:=GetNextByte; // ID_0
             ID1:=GetNextByte; // ID_1
             // now read until end command
             ReadByte:=GetNextByte;
             while ReadByte <> END_SYSEX do
             begin
               DataString:=DataString+chr(ReadByte);
               ReadByte:=GetNextByte;
             end;
             if Assigned(FOnExtendedSysex) then
               FOnExtendedSysex(self, ID0, ID1, DataString);
          end;
          {0  START_SYSEX       (0xF0)
          1  REPORT_VERSION     (0x79)
          2  major version     (0-127)
          3  minor version     (0-127)
          4  first char of firmware name (LSB)
          5  first char of firmware name (MSB)
          6  second char of firmware name (LSB)
          7  second char of firmware name (MSB)
          ... for as many bytes as it needs
          N  END_SYSEX         (0xF7)}
          REPORT_FIRMWARE: begin // 0x79
             FFirmataFirmware[0]:=GetNextByte;
             FFirmataFirmware[1]:=GetNextByte;
             ReadByte:=GetNextByte;
             while ReadByte <> END_SYSEX do  // Read Firmware string each char are 2 bytes (low byte, high byte)
             begin
               DataString:=DataString+Chr(ReadByte);
               ReadByte:=GetNextByte;
             end;
             DataString:=Decode2BytesCharTo1(DataString);  // converts 2 bytes char to 1 byte char
             FFirmataStringFirmware:=DataString+' firmware('+IntToStr(FFirmataFirmware[0])+'.'+IntToStr(FFirmataFirmware[1])+
                          ') version('+IntToStr(FFirmataVersion[0])+'.'+IntToStr(FFirmataVersion[1])+')';
             FGotFirmware:=True;
             if (FFirmataFirmware[0] > FIRMWARE_MAJOR_VERSION) or (FFirmataFirmware[1] < FIRMWARE_MINOR_VERSION) then
                comException(1035, 'GetSysExCommand');
             if FStarting and not FGotCapabilities then
                askBoardCapabilities; // because some firmata does not send capabilities by default
          end;
          {0  START_SYSEX              (0xF0)
          1  CAPABILITY_RESPONSE       (0x6C)
          2  1st supported mode of pin 0
          3  1st mode's resolution of pin 0
          4  2nd supported mode of pin 0
          5  2nd mode's resolution of pin 0
          ... additional modes/resolutions, followed by `0x7F`,
          to mark the end of the pin's modes. Subsequently, each pin
          follows with its modes/resolutions and `0x7F`,
          until all pins are defined.
          N  END_SYSEX                (0xF7)}
          CAPABILITY_RESPONSE: begin // 0x6C;
             ReadByte:=GetNextByte;
             Pin:=0;
             AnalogPin:=0;
             while ReadByte <> END_SYSEX do  // for all pin modes
             begin
                // New pin element
                Setlength(FPins,Pin+1);  // increment size of array of pins
                FPins[pin].Busy:=nil;  // Pin no assigned to any module
                FPins[pin].Value:=0;
                FPins[pin].State:=0;
                FPins[pin].AnalogMap:=PIN_MODE_IGNORE; // default no analog pin map
                if FFirmataType = FirmataPlus then
                  FPins[pin].ActualMode:=PIN_MODE_INPUT // FirmataPlus default pin mode
                else
                  FPins[pin].ActualMode:=PIN_MODE_OUTPUT; // StandardFirmata default pin mode

                if ReadByte = PIN_MODE_IGNORE then
                begin
                  FPins[pin].ActualMode:=PIN_MODE_IGNORE; // if first mode is PIN_MODE_IGNORE then pin must be ignored
                end
                else
                  while ReadByte <> PIN_MODE_IGNORE do
                  begin
                     // New pin capability
                     SetLength(FPins[pin].Capabilities, Length(FPins[Pin].Capabilities)+1);
                     FPins[Pin].Capabilities[Length(FPins[Pin].Capabilities)-1].mode:=ReadByte;
                     if ReadByte = PIN_MODE_ANALOG then  // new analog pin discovered
                     begin
                       FPins[pin].AnalogMap:=AnalogPin;  // map analog Pin
                       FPins[pin].ActualMode:=PIN_MODE_ANALOG; // standardfirmata for analog input pin default
                       inc(AnalogPin);
                     end;
                     ReadByte:=GetNextByte;  // read resolution for other than analogic mode
                     FPins[Pin].Capabilities[Length(FPins[Pin].Capabilities)-1].Resolution:=ReadByte; // store Resolution
                     ReadByte:=GetNextByte; // read next capability
                  end; // end pin
                inc(Pin);    // next pin number
                ReadByte:=GetNextByte;
             end; // end all Pins
             FPinsNumber:=Pin;  // discovered pins
             FAnalogPinsNumber:=AnalogPin;  // discovered analog pins
             if FGotCapabilities then
             begin
               if Assigned(FOnCapabilities) then // is not from start or reset
                 FOnCapabilities(self);
             end
             else
             begin
               FGotCapabilities:=true;
               if FGotVersion and FGotFirmware then //is from start or reset
               begin
                 FStarting:=False;
                 FEnabled:=true;
                 Info;
                 if Assigned(FOnFirmataReady) then
                   FOnFirmataReady(self);
               end;
             end;
          end;
          {0  START_SYSEX              (0xF0)
          1  ANALOG_MAPPING_RESPONSE   (0x6A)
          2  analog channel corresponding to pin 0, or 127 if pin 0 does not support analog
          3  analog channel corresponding to pin 1, or 127 if pin 1 does not support analog
          4  analog channel corresponding to pin 2, or 127 if pin 2 does not support analog
          ... etc, one byte for each pin
          N  END_SYSEX                (0xF7)}
          ANALOG_MAPPING_RESPONSE: begin // $6A
            if FStarting then // avoid problems with some firmatas
            begin
              Repeat
              until GetNextByte = END_SYSEX;
            end
            else // Firmata has already started, so normal behavior
            begin
              ReadByte:=GetNextByte;
              Pin:=0;
              while ReadByte <> END_SYSEX do
              begin
                FPins[Pin].AnalogMap:=ReadByte;  // Pin map
                Inc(Pin);  // next pin
                ReadByte:=GetNextByte;
              end;
             end;
          end;
          {0  START_SYSEX              (0xF0)
           1  PIN_STATE_RESPONSE       (0x6E)
           2  pin                      (0-127)
           3  pin mode (the currently configured mode)
           4  pin state, bits 0-6
           5  (optional) pin state, bits 7-13
           6  (optional) pin state, bits 14-20
           ... additional optional bytes, as many as needed
           N  END_SYSEX                (0xF7)}
          PIN_STATE_RESPONSE: begin // $6E  max 64 bits
                Pin:=GetNextByte;
                Mode:=GetNextByte;
                ReadByte:=GetNextByte;
                while ReadByte <> END_SYSEX do
                begin
                  DataString:=DataString+chr(ReadByte);   // First Char is LSB
                  ReadByte:=GetNextByte;
                end;

                DataString:=Decode7To8bit(DataString);  // converts to 8 bits
                Value:=StrByteToInt(DataString);  // converts to int

                if (Value=0) and (FPins[Pin].State<>0) then  // firmata does not report the state right
                  Value:=FPins[Pin].State; // from FPins, last written value

                if Assigned(FOnPinStateChange) then
                  FOnPinStateChange(self,Pin,Mode,Value);
          end;
          {0  START_SYSEX              (0xF0)
          1  EXTENDED_ANALOG           (0x6F)
          2  pin                      (0-127)
          3  bits 0-6                 (least significant byte)
          4  bits 7-13                (most significant byte)
          ... additional bytes may be sent if more bits are needed
          N  END_SYSEX                (0xF7)}
          EXTENDED_ANALOG: begin //  $6F
              Pin:=GetNextByte;
              ReadByte:=GetNextByte;
              while ReadByte <> END_SYSEX do
              begin
                DataString:=DataString+chr(ReadByte);   // First Char is LSB
                ReadByte:=GetNextByte;
              end;
              DataString:=Decode7To8bit(DataString);  // convert to 8 bits
              Value:=StrByteToInt(DataString);  // converts to int
              FPins[Pin].Value:=Value; // Store Pin value read

              if Assigned(FOnPinValueChange) then
                FOnPinValueChange(self, Pin, Value);
          end;
          {0  START_SYSEX        (0xF0)
          1  STRING_DATA        (0x71)
          2  first char LSB
          3  first char MSB
          4  second char LSB
          5  second char MSB
          ... additional bytes up to half the buffer size - 3 (START_SYSEX, STRING_DATA, END_SYSEX)
          N  END_SYSEX          (0xF7)}
          STRING_DATA: begin //  $71
             ReadByte:=GetNextByte;
             while ReadByte <> END_SYSEX do
             begin
                DataString:=DataString+Char(ReadByte);
                ReadByte:=GetNextByte;
             end;
             DataString:=Decode2BytesCharTo1(DataString);
             if Assigned(FOnFirmataData) then
                  FOnFirmataData(self, STRING_DATA, DataString);
          end;
          SERIAL_MESSAGE: begin // $60
             {if FFirmataSerial = nil then }
               Repeat
               until GetNextByte = END_SYSEX;
             // TODO
             //FFirmataSerial.GetSysExSerial
          end;
          SCHEDULER_DATA: begin // scheduler $7B
            if Assigned(FFirmataTasks) and FFirmataTasks.Enabled then
              FFirmataTasks.GetFirmataCommand(Self, GetNextByte)
            else   // Module is not asigned or enabled
            begin
              comException(32,'FirmataTask');
              Repeat
              until GetNextByte = END_SYSEX; // discart command
            end;
          end;
          I2C_REPLY: begin // $77
            if Assigned(FFirmataI2C) and FFirmataI2C.Enabled then
              FFirmataI2C.GetFirmataCommand(Self)
            else   // Module is not asigned or enabled
            begin
              comException(32,'FirmataI2C');
              Repeat
              until GetNextByte = END_SYSEX; // discart command
            end;
          end;
          ONEWIRE_DATA: begin //  $73;
            if Assigned(FFirmataOneWire) and FFirmataOneWire.Enabled then
              FFirmataOneWire.GetFirmataCommand(Self, GetNextByte)
            else   // Module is not asigned or enabled
            begin
              comException(32,'FirmataOneWire');
              Repeat
              until GetNextByte = END_SYSEX; // discart command
            end;
          end;
          ACCELSTEPPER_DATA: begin                   //      (0x62)
             //if FFirmataAccelStepper = nil then
             Repeat
             until GetNextByte = END_SYSEX;
           // TODO
          end;
          else   // Sysex command unknown
          begin
            // now read until end command
            ReadByte:=GetNextByte;
            while ReadByte <> END_SYSEX do
            begin
                DataString:=DataString+chr(ReadByte);
                ReadByte:=GetNextByte;
            end;
            comException(4, 'GetSysExCommandData', Command);
          end;
     end;
end;
// converts Byte string values into hex string
function TFirmataBoard.StrToHex(const Buffer: string): string;
begin
  SetLength(result, 2*Length(Buffer));
  BinToHex(@Buffer[1], @result[1], Length(Buffer));
end;

// converts Byte string values into a separated hex string
function TFirmataBoard.StrToHexSep(const Value: String): string;
var
  n: Integer;
begin
  Result := '';
  for n := 1 to Length(Value) do
    Result := Result + Format('%3.2x', [ord(Value[n])]);
  Result := upperCase(Result);
end;

// converts a value into a byte string low byte first
function TFirmataBoard.IntToStrByte(Value: Integer; size: Byte): String;
var
  i: integer;
  TmpValue: integer;
begin
  TmpValue:=Value;
  Result:='';
  for i:=1 to Size do
  begin
    Result:=Result+chr(TmpValue and $FF);
    TmpValue:=TmpValue >> 8;
  end;
end;

// converts a string of bytes, low byte first, into a int value
function TFirmataBoard.StrByteToInt(DataString: String): integer;
var
  i: integer;
begin
  Result:=0;

  for i:=length(DataString) downto 1 do
  begin
    Result:=(Result << 8);
    Result:=Result+ord(DataString[i]);
  end;
end;

// Get string data 7 bit encoded and decode to 8 bit data string
function TFirmataBoard.Decode7To8bit(Data7bit: string): String;
var
   rotate: integer;
   i: integer;
begin
    rotate:=0;
    Result:='';
    i:=1;
    While i<Length(Data7bit) do
    begin
       Result:=Result+chr((ord(Data7bit[i])>>rotate) or (ord(Data7bit[i+1])<<(7-rotate)));
       inc(i);
       inc(rotate);
       if rotate = 7 then
       begin
           inc(i);
           rotate:=0;
       end;
    end;
end;

// Get string Data 8 bit and encode to 7 bit Data string
function TFirmataBoard.Encode8To7Bit(Data8bit:string): string;
var
   rotate: integer;
   i: integer;
begin
    Result:='';
    if Data8Bit = '' then
      exit;

    i:=0;
    rotate:=8;
    while i<length(Data8Bit) do
    begin
      inc(i);
      if rotate=8 then
      begin
        Result:=Result+chr(ord(Data8bit[i]) and $7F);
        rotate:=1;
      end;
      if i<length(Data8Bit) then
         Result:=Result+chr((ord(Data8bit[i])>>(8-rotate)) or ((ord(Data8bit[i+1])<<rotate) and $7F))
      else
         Result:=Result+chr(ord(Data8bit[i])>>(8-rotate));
      inc(rotate);
    end;
end;
// converts a 2 bytes char into a 1 byte char
function TFirmataBoard.Decode2BytesCharTo1(Data2bytes: string): string;
var
  i: integer;
begin
  Result:='';
  i:=1;
  while i < Length(Data2bytes) do
  begin
    Result:=Result+chr(ord(Data2bytes[i]) or (ord(Data2bytes[i+1]) << 7));
    i:=i+2;
  end;
end;
// converts a 1 byte char into a 2 bytes char
function TFirmataBoard.Encode1ByteCharTo2(Data1Byte: string): string;
var
  i: integer;
begin
  Result:='';
  for i:=1 to Length(Data1Byte) do
  begin
    Result:=Result+chr(ord(Data1Byte[i]) and $7F)+chr(ord(Data1Byte[i]) >> 7);
  end;
end;

{0  START_SYSEX              (0xF0)
1  pin state query          (0x6D)
2  pin                      (0-127)
3  END_SYSEX                (0xF7)}
function TFirmataBoard.askPinState(Pin: byte; write: Boolean=true): string;
begin
  Result:='';
  if Pin > FPinsNumber then
  begin
      comException(7, 'askPinState', Pin);
      exit;
  end;

  Result:=SendSysEx(chr(PIN_STATE_QUERY)+chr(Pin), write);
end;

{report digital port 	0xD0 	port 	disable/enable(0/1) 	- n/a -}
function TFirmataBoard.DigitalReport(port: byte; enabled: boolean; write: Boolean=true): string;
begin
  Result:=DigitalReport(port, enabled, 8, write); // 8 pins in port
end;

function TFirmataBoard.DigitalReport(port: byte; enabled: boolean; PortPins: byte; write: Boolean=true): string;  // default 8 pins per port
begin
   Result:='';
   if (Port*PortPins+PortPins)> (Length(FPins)-1) then
   begin
      comException(8, 'DigitalReport', Port);
      exit;
   end;

  Result:=SendCommand(chr(REPORT_DIGITAL or port)+chr(ord(enabled)), write);
end;

{report analog pin 	0xC0 	pin # 	disable/enable(0/1) 	- n/a - }
function TFirmataBoard.AnalogReport(AnalogPin: byte; enabled: boolean; write: Boolean=true): string;
var
  Pin: Byte;
begin
  Result:='';

  Pin:=GetPinFromAnalogPin(AnalogPin);  // get pin mappped to that analog pin

  if Pin = $FF then
  begin
    comException(9, 'AnalogReport', Pin);
    exit;
  end;
  // check first
  if FPins[Pin].ActualMode <> PIN_MODE_ANALOG then
  begin
    comException(10, 'AnalogReport', AnalogPin);
    exit;
  end;

  Result:=SendCommand(chr(REPORT_ANALOG or Pin)+chr(ord(enabled)), write);
end;

{0  digital data, 0x90-0x9F, (MIDI NoteOn, bud different data format)
1  digital pins 0-6 bitmask
2  digital pin 7-13 bitmask}
function TFirmataBoard.DigitalWritePort(Port: byte; Value: integer; write: Boolean=True): string;
begin
  Result:=DigitalWritePort(Port,  Value, 8, write);  // 8 bits in port
end;

function TFirmataBoard.DigitalWritePort(Port: byte; Value: integer; PortPins: byte; write: Boolean=true): string;
var
  Pin: Byte;
  mask: integer;
begin
  Result:='';
  if (Port*PortPins+PortPins) > (Length(FPins)-1) then
  begin
      comException(8, 'DigitalWritePort', Port);
      exit;
  end;

  mask:=1;
  for Pin:=Port*PortPins to Port*PortPins+(PortPins-1) do // default 8 pins in port
  begin
    if FPins[Pin].ActualMode in [PIN_MODE_OUTPUT, PIN_MODE_INPUT, PIN_MODE_PULLUP] then
    begin
      if (Value and mask)>0 then  // write a 1
          FPins[Pin].State:=HIGH
      else      // write a 0
          FPins[Pin].State:=LOW;
    end;
    mask:=mask << 1; // next pin mask
  end;

  Result:=SendCommand(chr(DIGITAL_MESSAGE or Port)+chr(Value and $7F)+chr((value >> 7) and $7F), write);
end;

{0  digital data, 0x90-0x9F, second nibble of byte 0 gives the port number (e.g. 0x92 is the third port, port 2)
1  digital pins 0-6 bitmask
2  digital pin 7-13 bitmask}
procedure TFirmataBoard.GetDigitalMessage(Command: byte); // port number, get digital 8 bits in port
begin
  GetDigitalMessage(Command, 8);
end;

procedure TFirmataBoard.GetDigitalMessage(Command: byte; PortPins: byte);  // default 8 pins per port
var
  Pin: Byte;
  Port: byte;
  DigitalValues: integer;
  mask: integer;
begin
    {port = Command; port_data = data[self.LSB] + (data[self.MSB] << 7)
   set all the pins for this reporting port get the first pin number for this report
   pin = port * PortPins}
     mask:=1;
     Port:= Command and $0F; // port number
     DigitalValues:=(GetNextByte and $7F) or ((GetNextByte << 7) and $7F);

     for Pin:=Port*PortPins to Port*PortPins+(PortPins-1) do // PortPins pins in port, default 8 pins
     begin
        if Boolean(DigitalValues and mask) then  // get Digital Value for pin
        begin
          if FPins[Pin].Value = LOW then // pin has changed value
          begin
            FPins[Pin].Value:=HIGH;
            if Assigned(FOnPinValueChange) then
              FOnPinValueChange(self,Pin,HIGH);
          end;
        end
        else
        begin
           if FPins[Pin].Value = HIGH then  // pin has changed value
           begin
             FPins[Pin].Value:=LOW;
             if Assigned(FOnPinValueChange) then
               FOnPinValueChange(self,Pin,LOW);
           end;
        end;
        mask:=mask << 1; // next pin mask
    end;
end;

function TFirmataBoard.GetPinFromAnalogPin(AnalogPin: byte): Byte;
var
  i: integer;
begin
  Result:=$FF;
  if AnalogPin > FAnalogPinsNumber then
    exit;
  for i:=0 to Length(FPins) - 1 do
  begin
    if FPins[i].AnalogMap = AnalogPin then
    begin
      Result:=i;
      Break;
    end;
  end;
end;

{0  set digital pin mode (0xF4) (MIDI Undefined)
1  set pin number (0-127)
2  mode (INPUT/OUTPUT/ANALOG/PWM/SERVO/I2C/ONEWIRE/STEPPER/ENCODER/SERIAL/PULLUP, 0/1/2/3/4/6/7/8/9/10/11)}
function TFirmataBoard.SetPinMode(Pin: byte; Mode: Byte; write: Boolean=true): string; // if write true then send bytes to device
var
  ModeTmp: Byte;
begin
  Result:='';

  if Pin > FPinsNumber then
  begin
      comException(7, 'SetPinMode', Pin);
      exit;
  end;
  // check for modes
  Modetmp:=FPinModesMap[Mode]; // new pin mode
  if Modetmp=FPins[Pin].ActualMode then  //mode has not changed
    exit;

  // check if supported
  if not CheckCapability(Pin, Mode) then
  begin
     comException(11, 'SetPinMode', Mode);
     exit;
  end;

  FPins[Pin].ActualMode:=ModeTmp;
  if Modetmp=PIN_MODE_PULLUP then
    FPins[Pin].State:=HIGH;

  FPins[Pin].Value:=0; // after change pin mode firmata set value to 0

  Result:=SendCommand(chr(SET_PIN_MODE)+chr(Pin)+chr(Modetmp), write) // $F4   );
end;
// check if supported capability
function TFirmataBoard.CheckCapability(Pin: byte; Mode: Byte): Boolean;
var
  i: integer;
begin
  Result:=False;
  for i:=0 to length(FPins[Pin].Capabilities)-1 do
  begin
     if FPins[Pin].Capabilities[i].Mode = Mode then
     begin
        Result:=True;
        break;
     end;
  end;
end;
// get resolution of pin
function TFirmataBoard.GetPinResolution(Pin: Byte; Mode: Byte): Integer;
var
  i: integer;
  NotFound: Boolean;
begin
  Result:=0;
  NotFound:=true;
  for i:=0 to length(FPins[Pin].Capabilities)-1 do
  begin
    if FPins[Pin].Capabilities[i].Mode = FPins[Pin].ActualMode then
    begin
      Result:=(1 << FPins[Pin].Capabilities[i].Resolution) - 1; // get resolution
      NotFound:=false;
      break;
    end;
  end;
  if NotFound then
    comException(34, 'SetPinMode', Mode);
end;

function TFirmataBoard.DigitalWrite(Pin: byte; Value: Byte; write: Boolean=true): string;
begin
   Result:=SetDigitalPinValue(Pin, Value, write);
end;

{set digital pin value}
{0  set digital pin value (0xF5) (MIDI Undefined)
1  set pin number (0-127)
2  value (LOW/HIGH, 0/1)}
function TFirmataBoard.SetDigitalPinValue(Pin: byte; Value: Byte; write: Boolean=true): string;
begin
    Result:='';

    if Pin > FPinsNumber then
    begin
      comException(7, 'SetDigitalPinValue', Pin);
      exit;
    end;

    if not (FPins[Pin].ActualMode in [PIN_MODE_OUTPUT, PIN_MODE_INPUT, PIN_MODE_PULLUP]) then
    begin
       comException(7, 'SetDigitalPinValue', Pin);
       exit;
    end;

    if Value <> 0 then
      FPins[Pin].State:=HIGH
    else
      FPins[Pin].State:=LOW;

   Result:=SendCommand(chr(SET_DIGITAL_PIN_VALUE)+chr(Pin)+chr(FPins[Pin].State), write); // $F5
end;

function TFirmataBoard.AnalogWriteExtended(Pin: Byte; Value: integer; write: Boolean=True): string;
begin
   Result:=SendExtendedAnalog(Pin, Value, write);
end;

{0  START_SYSEX              (0xF0)
1  extended analog message  (0x6F)
2  pin                      (0-127)
3  bits 0-6                 (least significant byte)
4  bits 7-13                (most significant byte)
... additional bytes may be sent if more bits are needed
N  END_SYSEX                (0xF7)}
function TFirmataBoard.SendExtendedAnalog(Pin: Byte; Value: integer; write: Boolean=true): string; // analog write (PWM, Servo, etc) to any pin
var
  i: integer;
  Valuetmp: integer;
  data: String;
begin
  Result:='';
  data:='';
  if Pin > FPinsNumber then
  begin
      comException(7, 'SendExtendedAnalog', Pin);
      exit;
  end;
  // check valid modes
  if not (FPins[Pin].ActualMode in [PIN_MODE_PWM, PIN_MODE_SERVO]) then
  begin
       comException(11,'SendExtendedAnalog', FPins[Pin].ActualMode);
       exit;
  end;
  // search for resolution
  ValueTmp:=Value and GetPinResolution(Pin, FPins[Pin].ActualMode);

  FPins[Pin].State:=Valuetmp;   //store value written in FPins

  for i:=0 to sizeof(Valuetmp) do
  begin
    data:=chr(Valuetmp and $FF)+data;  // LSB byte ,MSB byte
    Valuetmp:=Valuetmp>>8; // get new byte
    if Valuetmp = 0 then  // no more data to send
      break;
  end;

  Result:=SendSysEx(chr(EXTENDED_ANALOG)+chr(Pin)+Encode8To7Bit(data), write);
end;

function TFirmataBoard.AnalogWrite(AnalogPin: byte; Value: integer; write: Boolean=true): string;
begin
  Result:=SendAnalogMessage(AnalogPin,Value,write);
end;

{0  analog pin, 0xE0-0xEF, (MIDI Pitch Wheel)
1  analog least significant 7 bits
2  analog most significant 7 bits }
function TFirmataBoard.SendAnalogMessage(AnalogPin: byte; Value: integer; write: Boolean=True): string;
var
   Pin: byte;
   Valuetmp: integer;
begin
    Result:='';

    Pin:=GetPinFromAnalogPin(AnalogPin); // map real pin

    if FPins[Pin].ActualMode<>PIN_MODE_PWM then
    begin
       comException(11, 'SendAnalogMessage', FPins[Pin].ActualMode);
       exit;
    end;

    // search for resolution
    ValueTmp:=Value and GetPinResolution(Pin, FPins[Pin].ActualMode);

    FPins[Pin].State:=Valuetmp;  // store last value written

    Result:=SendCommand(chr(ANALOG_MESSAGE)+chr(Valuetmp and $7F)+chr(Valuetmp >> 7 and $7F),write);
end;

{system reset 	0xFF}
function TFirmataBoard.BoardReset(write: Boolean=true): string;
begin
     //FLazSerial.SynSer.Purge; // clear all data in serial port
     Result:=SendCommand(chr(SYSTEM_RESET), write);
end;

{0  analog pin, 0xE0-0xEF, (MIDI Pitch Wheel)
 1  analog least significant 7 bits
 2  analog most significant 7 bits}
procedure TFirmataBoard.GetAnalogMessage(Command: byte);
var
  Pin: Byte;
  AnalogPin: byte;
  Value: integer;
begin
   AnalogPin:= Command and $0F; // Channel number
   Pin:=GetPinFromAnalogPin(AnalogPin);  // Get Pin number from analog pin
   Value:=GetNextByte or (GetNextByte << 7);

   FPins[Pin].Value:=Value;   // store in FPins too

   if Assigned(FOnPinValueChange) then
     FOnPinValueChange(self,Pin,Value);
end;

{ Send START_SYSEX + data + END_SYSEX total <= MAX_DATA_BYTES (64 bytes)}
function TFirmataBoard.SendSysEx(data7bit: string; write: Boolean=true): string;
begin
  Result:='';
  if Length(data7bit) > (MAX_DATA_BYTES - 2) then
  begin
    comException(21, 'SendSysEx', Length(data7bit)+2);
    exit;
  end;
  Result:=chr(START_SYSEX)+Data7bit+chr(END_SYSEX);
  if write then
  begin
    if Assigned(OnSendDataToDevice) then
    begin
      FOnSendDataToDevice(self, Result);
      sleep(FSamplingInterval+length(Result));  // gives some time to Firmata
    end
    else
      comException(1, 'SendSysEx');
    Result:='';
  end;
end;

// This method is used to transmit a non-sysex command.
function TFirmataBoard.SendCommand(Data: string; write: Boolean=True): string;
begin
  Result:=Data;
  if write then
  begin
    if Assigned(OnSendDataToDevice) then
    begin
      FOnSendDataToDevice(self, Data);
      sleep(FSamplingInterval+length(Result));  // gives some time to Firmata
    end
    else
      comException(1, 'SendCommand');
    Result:='';
  end;
end;

function TFirmataBoard.ReversePinModesMap(Mode: byte): byte;
var
  i: byte;
begin
  for i:=0 to Length(FPinModesMap) do
  begin
     if Mode=FPinModesMap[i] then
       break;
  end;
  Result:=i;
end;

function TFirmataBoard.PinModesText(Mode: byte): string;
begin
  case ReversePinModesMap(Mode) of
      PIN_MODE_INPUT: Result:='INPUT';
      PIN_MODE_OUTPUT: Result:='OUTPUT';
      PIN_MODE_ANALOG: Result:='ANALOG';
      PIN_MODE_PWM: Result:='PWM';
      PIN_MODE_SERVO: Result:='SERVO';
      PIN_MODE_SHIFT: Result:='SHIFT';
      PIN_MODE_I2C: Result:='I2C';
      PIN_MODE_ONEWIRE: Result:='ONEWIRE';
      PIN_MODE_STEPPER: Result:='STEPPER';
      PIN_MODE_ENCODER: Result:='ENCODE';
      PIN_MODE_SERIAL: Result:='SERIAL';
      PIN_MODE_PULLUP: Result:='PULLUP';  // adapted to work on firmataplus
      12: Result:='SONAR';  //FirmataPlus
      13: Result:='TONE';  //FirmataPlus
      $7F: Result:='IGNORE PIN';
  end;
end;

procedure TFirmataBoard.printPinInfo(Memo: TMemo);
var
  pin : integer;
  Line: string;
  i: integer;
begin
  //memo.Append('');
  //Memo.Append('Firmata capabilities');
  memo.Append('');
  for pin:=0 to length(FPins)-1 do
  begin
       Line:=pin.ToString+': Mode=';
       if FPins[pin].ActualMode = $7F then begin
              Line:=Line+'No operational pin';
       end
       else
       begin
         Line:=Line+PinModesText(FPins[pin].ActualMode);
         Line:=Line+', Capabilities=';
         for i:=0 to Length(FPins[Pin].Capabilities)-1 do
         begin
           Line:=Line+PinModesText(FPins[pin].Capabilities[i].mode)+'('+IntToStr(FPins[pin].Capabilities[i].Resolution)+' bit), ';
         end;
       end;
       if RightStr(Line,2)=', ' then
         LeftStr(Line, Length(Line)-2);

       Memo.Append(Line);
  end;
end;
//
//
//
{ TFirmataTasks }
//
//
//
constructor TFirmataTasks.Create(AOwner: TComponent);
begin
  inherited;

  FFirmataBoard:= nil;
  FEnabled:=false;

  FOnEnabled:=nil;
  FOnDisabled:=nil;

  FOnTaskError:=nil;
  FOnQueryAllTask:=nil;
  FOnQueryTask:=nil;

  FTasks:=nil;
end;

destructor TFirmataTasks.Destroy();
begin
  inherited Destroy;
end;

procedure TFirmataTasks.setFirmataBoard(Board: TFirmataBoard);
begin
  if Assigned(Board) then
    FFirmataBoard:=Board;
end;

procedure TFirmataTasks.setEnabled(State: Boolean);
begin
  if not Assigned(FFirmataBoard) then
    exit;

  if FEnabled = State then
     exit;

  if State then
  begin
    FEnabled:=True;
    if Assigned(FFirmataBoard) and FFirmataBoard.Enabled then
      FFirmataBoard.FirmataTasks:=self
    else
      FEnabled:=false;
    if Assigned(FOnEnabled) then
      FOnEnabled(self);
  end
  else  // disable
  begin
    if Assigned(FOnDisabled) then
      FOnDisabled(self);
    if Assigned(FFirmataBoard) then
      FFirmataBoard.FirmataTasks:=nil;
    FEnabled:=False;
  end;
end;

function TFirmataTasks.GetNextByte: Byte;
begin
   Result:=FFirmataBoard.GetNextByte;
end;

procedure TFirmataTasks.GetFirmataCommand(Sender: TObject; Command: Byte);
var
  ReadByte: byte;
  TaskID: byte;
  DataString: string;
  Time_ms: integer;
  Length: integer;
  Position: integer;
  TaskIDs: array of Byte;
begin
  TaskIDs:=nil;
  DataString:='';
  TaskID:=0;
  Time_ms:=0;
  Length:=0;
  Position:=0;

  case Command of
    {0  START_SYSEX              (0xF0)
    1  Scheduler Command        (0x7B)
    2  error_task Reply Command (0x08) or query_task Reply Command (0x0A)
    3  task id                  (0-127)
    4  time_ms bit 0-6
    5  time_ms bit 7-13
    6  time_ms bit 14-20
    7  time_ms bit 21-27
    8  time_ms bit 28-31 | (length bit 0-2) << 4
    9  length bit 3-9
    10 length bit 10-15 | (position bit 0) << 7
    11 position bit 1-7
    12 position bit 8-14
    13 position bit 15 | taskdata bit 0-5 << 1 [taskdata is optional]
    14 taskdata bit 6-12  [optional]
    15 taskdata bit 13-19 [optional]
    n  ... as many bytes as needed (don't exceed MAX_DATA_BYTES though)
    n+1  END_SYSEX              (0xF7) }
    ERROR_FIRMATA_TASK, QUERY_TASK_REPLY: begin // error_task Reply Command (0x08)
      ReadByte:=GetNextByte;
      if ReadByte <> END_SYSEX then
      begin
        TaskID:=ord(ReadByte);  // get task ID
        ReadByte:=GetNextByte;
        while ReadByte <> END_SYSEX do
        begin
          DataString:=DataString+chr(ReadByte);
          ReadByte:=GetNextByte;
        end;
        if system.Length(DataString)>0 then
        begin
          DataString:=FFirmataBoard.Decode7To8bit(DataString);  // decode 7 bits string
          Time_ms:=FFirmataBoard.StrByteToInt(Copy(DataString,1,4)); // first 32 bits, 4 bytes
          Length:=FFirmataBoard.StrByteToInt(Copy(DataString,5,2));  // next 16 bits, 2 bytes
          Position:=FFirmataBoard.StrByteToInt(Copy(DataString,7,2));  // next 16 bits, 2 bytes
          DataString:=Copy(DataString,9,system.Length(DataString)-8);  // Task Data
        end;

        if Command = QUERY_TASK_REPLY then
        begin
          if Assigned(FOnQueryTask) then
            FOnQueryTask(self, TaskID, Time_ms, Length, Position, DataString);
        end
        else // ERROR_TASK_REPLY
          if Assigned(FOnTaskError) then
            FOnTaskError(self, TaskID, Time_ms, Length, Position, DataString);
      end;
    end;
    {0  START_SYSEX          (0xF0)
    1  Scheduler Command    (0x7B)
    2  query_all_tasks Reply Command (0x09)
    3  taskid_1             (0-127) [optional]
    4  taskid_2             (0-127) [optional]
    n  ... as many bytes as needed (don't exceed MAX_DATA_BYTES though)
    n+1  END_SYSEX (0xF7)}
    QUERY_ALL_TASKS_REPLY: begin // query_all_tasks Reply Command (0x09)
      SetLength(TaskIDs,0);
      ReadByte:=GetNextByte;
      while ReadByte <> END_SYSEX do
      begin
        Setlength(TaskIDs,system.length(TaskIDs)+1);
        TaskIDs[system.length(TaskIDs)-1]:=ReadByte;
        ReadByte:=GetNextByte;
      end;
      if Assigned(FOnQueryAllTask) then
        FOnQueryAllTask(self, TaskIDs);
    end;
    else
    begin  // unknown Scheduler command, now read until end command
      ReadByte:=GetNextByte;
      while ReadByte <> END_SYSEX do
      begin
        DataString:=DataString+chr(ReadByte);
        ReadByte:=GetNextByte;
      end;
      FFirmataBoard.ComException(4, 'GetSchedulerCommands', Command);
    end;
  end;
end;

//
// SCHEDULER COMMANDS
//
{0  START_SYSEX          (0xF0)
 1  Scheduler Command    (0x7B)
 2  create_task command  (0x00)
 3  task id              (0-127)
 4  length LSB           (bit 0-6)
 5  length MSB           (bit 7-13)
 6  END_SYSEX            (0xF7) }
function TFirmataTasks.CreateTask(TaskID: Byte; Length: integer; write: Boolean=true): string;
var
  Exists: Boolean;
  i: integer;
begin
  Result:='';
  exists:=false;
  if TaskID > 127 then
  begin
    FFirmataBoard.comException(5,'CreateTask', TaskID);
    exit;
  end;
  if Length > $3FFF then // 14 bits
  begin
    FFirmataBoard.comException(6, 'CreateTask', TaskID);
    exit;
  end;
  for i:=0 to system.Length(FTasks)-1 do
  begin
    if FTasks[i].ID = TaskID then // task exists, clear data
    begin
      FTasks[i].Size:=Length;
      Exists:=true;
      break;
    end;
  end;
  if Not Exists then  // new task
  begin
    i:=system.Length(FTasks);
    SetLength(FTasks, i+1);
    FTasks[i].ID:=TaskID;
    FTasks[i].Data:='';
    FTasks[i].size:=Length;
  end;
  Result:=FFirmataBoard.SendSysEx(chr(SCHEDULER_DATA)+chr(CREATE_TASK)+chr(TaskID and $7F)+chr(Length and $7F)+chr((Length >> 7) and $7F), write);
end;
{0  START_SYSEX          (0xF0)
 1  Scheduler Command    (0x7B)
 2  delete_task command  (0x01)
 3  task id              (0-127)
 4  END_SYSEX            (0xF7)}
function TFirmataTasks.DeleteTask(TaskID: Byte; write: Boolean=true): string;
var
  i,j: integer;
  Exists: Boolean;
begin
  Result:='';
  exists:=false;

  j:=Length(FTasks)-1; // last element
  for i:=0 to j do
  begin
    if FTasks[i].ID = TaskID then // exists
    begin
      FTasKs[i].ID:=FTasKs[j].ID;  // copy last element in this position
      FTasks[i].Data:=FTasks[j].Data;
      FTasks[i].size:=FTasks[j].size;
      SetLength(FTasks, j); // new size of array
      Exists:=True;
      break;
    end;
  end;
  if not exists then
  begin
    FFirmataBoard.comException(22,'DeleteTask', TaskID);
    exit;
  end;
  Result:=FFirmataBoard.SendSysEx(chr(SCHEDULER_DATA)+chr(DELETE_TASK)+chr(TaskID), write);
end;
{0  START_SYSEX          (0xF0)
1  Scheduler Command    (0x7B)
2  add_to_task command  (0x02)
3  task id              (0-127)
4  taskdata bit 0-6     [optional] task bytes encoded using 8 times 7 bit
                         for 7 bytes of 8 bit
5  taskdata bit 7-13    [optional]
6  taskdata bit 14-20   [optional]
n  ... as many bytes as needed (don't exceed MAX_DATA_BYTES though)
n+1  END_SYSEX          (0xF7)}
function TFirmataTasks.AddToTask(TaskID: Byte; Data7Bit: String; write: Boolean=true): string;
var
  i: integer;
  Exists: Boolean;
begin
  Result:='';

  exists:=false;
  if TaskID > 127 then
  begin
    FFirmataBoard.comException(5,'AddToTask', TaskID);
    exit;
  end;
  for i:=0 to Length(FTasks)-1 do
  begin
    if FTasks[i].ID = TaskID then // exists
    begin
      Exists:=True;
      if Length(Data7bit) > (MAX_DATA_BYTES - 5) then
      begin
        FFirmataBoard.comException(21,'AddToTask', Length(Data7bit) + 5);
        exit;
      end;
      FTasks[i].Data:=FTasks[i].Data+Data7Bit;
      break;
    end;
  end;
  if not exists then
  begin
    FFirmataBoard.comException(22,'AddToTask', TaskID);
    exit;
  end;

  Result:=FFirmataBoard.SendSysEx(chr(SCHEDULER_DATA)+chr(ADD_TO_TASK)+chr(TaskID)+Data7Bit, write);
end;
{0  START_SYSEX          (0xF0)
 1  Scheduler Command    (0x7B)
 2  delay_task command   (0x03)
 3  time_ms bit 0-6      time_ms is of type long, requires 32 bit.
 4  time_ms bit 7-13
 5  time_ms bit 14-20
 6  time_ms bit 21-27
 7  time_ms bit 28-31
 8  END_SYSEX            (0xF7)}
function TFirmataTasks.DelayTask(Delay: integer; write: Boolean=true): string;    // use for internal task
var
  Data8Bit: string;
begin
  Result:='';

  Data8Bit:=FFirmataBoard.IntToStrByte(Delay, 4);  // 4 byte, 32 bits
  Result:=FFirmataBoard.SendSysEx(chr(SCHEDULER_DATA)+chr(DELAY_TASK)+FFirmataBoard.Encode8To7Bit(Data8bit), write);
end;
{0  START_SYSEX              (0xF0)
 1  Scheduler Command        (0x7B)
 2  schedule_task command    (0x04)
 3  task id                  (0-127)
 4  time_ms bit 0-6          time_ms is of type long, requires 32 bit.
 5  time_ms bit 7-13
 6  time_ms bit 14-20
 7  time_ms bit 21-27
 8  time_ms bit 28-31
 9  END_SYSEX                (0xF7)}
function TFirmataTasks.ScheduleTask(TaskID: Byte; Time: integer; write: Boolean=true): string;
var
   Data8Bit: string;
   i: integer;
   Exists: Boolean;
begin
  Result:='';

  exists:=false;
  if TaskID > 127 then
  begin
    FFirmataBoard.comException(5,'ScheduleTask', TaskID);
    exit;
  end;
  for i:=0 to Length(FTasks)-1 do
  begin
    if FTasks[i].ID = TaskID then // exists
    begin
      Exists:=True;
      break;
    end;
  end;
  if not exists then
  begin
    FFirmataBoard.comException(22,'ScheduleTask', TaskID);
    exit;
  end;

  Data8Bit:=FFirmataBoard.IntToStrByte(Time, 4);  // 4 byte, 32 bits
  Result:=FFirmataBoard.SendSysEx(chr(SCHEDULER_DATA)+chr(SCHEDULE_TASK)+chr(TaskID)+FFirmataBoard.Encode8To7Bit(Data8bit), write);
end;
{0  START_SYSEX              (0xF0)
1  Scheduler Command        (0x7B)
2  query_all_tasks command  (0x05)
3  END_SYSEX                (0xF7) }
function TFirmataTasks.QueryAllTasks(write: Boolean=true): string;
begin
  Result:='';

  if Length(FTasks) = 0 then
  begin
    FFirmataBoard.comException(23,'QueryAllTasks');
    exit;
  end;
  Result:=FFirmataBoard.SendSysEx(chr(SCHEDULER_DATA)+chr(QUERY_ALL_TASKS), write);
end;
{0  START_SYSEX              (0xF0)
 1  Scheduler Command        (0x7B)
 2  query_task command       (0x06)
 3  task id                  (0-127)
 4  END_SYSEX                (0xF7) }
function TFirmataTasks.QueryTask(TaskID: Byte; write: Boolean=true): string;
var
  i: integer;
  Exists: Boolean;
begin
  Result:='';

  exists:=false;
  if TaskID > 127 then
  begin
    FFirmataBoard.comException(5,'QueryTask', TaskID);
    exit;
  end;
  for i:=0 to Length(FTasks)-1 do
  begin
    if FTasks[i].ID = TaskID then // exists
    begin
      Exists:=True;
      break;
    end;
  end;
  if not exists then
  begin
    FFirmataBoard.comException(22,'QueryTask', TaskID);
    exit;
  end;
  Result:=FFirmataBoard.SendSysEx(chr(SCHEDULER_DATA)+chr(QUERY_TASK)+chr(TaskID), write);
end;
{0  START_SYSEX              (0xF0)
 1  Scheduler Command        (0x7B)
 2  scheduler reset command  (0x07)
 3  END_SYSEX                (0xF7)}
function TFirmataTasks.SchedulerReset(write: Boolean=true): string;
begin
  FTasks:=nil;
  Result:=FFirmataBoard.SendSysEx(chr(SCHEDULER_DATA)+chr(SCHEDULER_RESET), write);
end;

//
//
//
{ TFirmataOneWire }
//
//
//
constructor TFirmataOneWire.Create(AOwner: TComponent);
begin
  inherited;

  FFirmataBoard:= nil;
  FEnabled:=false;

  FOnEnabled:=nil;
  FOnDisabled:=nil;

  FOnOneWireData:=nil;
  FOnOneWireSearch:=nil;
  FOnOneWireAlarm:=nil;
  FOneWirePin:=PIN_MODE_IGNORE;
  FParasitisticPower:=false;
end;

destructor TFirmataOneWire.Destroy();
begin
  inherited Destroy;
end;

procedure TFirmataOneWire.setFirmataBoard(Board: TFirmataBoard);
begin
  if Assigned(Board) then
    FFirmataBoard:=Board;
end;

procedure TFirmataOneWire.setOneWirePin(Pin: Byte);
begin
  if FEnabled then
  begin
    FFirmataBoard.comException(33, 'setOneWirePin');
    exit;
  end;
  FOneWirePin:=Pin;
end;

procedure TFirmataOneWire.setEnabled(State: Boolean);
begin
  if not Assigned(FFirmataBoard) then
    exit;

  if FEnabled = State then
     exit;

  if State then
  begin
    FEnabled:=True;
    if Assigned(FFirmataBoard) and FFirmataBoard.Enabled then
    begin
      FFirmataBoard.FirmataOneWire:=self;
      if FOneWirePin <> PIN_MODE_IGNORE then
      begin
        // Check if supported
        if not FFirmataBoard.CheckCapability(FOneWirePin, PIN_MODE_ONEWIRE) then // not supported
        begin
          FEnabled:=false;
          FFirmataBoard.comException(7, 'setOneWirePin', FOneWirePin);
        end
        else if not Assigned(FFirmataBoard.Pins[FOneWirePin].Busy) then  // supported pin, check if pin is assigned
        begin
          FFirmataBoard.FPins[FOneWirePin].Busy:=self;  //  pin is assigned to this module
          OnewireConfig(FOneWirePin, FParasitisticPower);  // configure onewire pin
        end
        else   // pin is busy
        begin
          FEnabled:=false;
          FFirmataBoard.comException(12, 'setOneWirePin', FOneWirePin);
        end;
      end
      else
      begin
        FEnabled:=false; // no onewire pin
        FFirmataBoard.comException(7, 'setOneWirePin', FOneWirePin);
      end;
    end
    else
    begin
      FEnabled:=false; // firmataboard not enabled
      FFirmataBoard.comException(36, 'setOneWirePin');
    end;
    if not FEnabled then
    begin
      FFirmataBoard.FirmataOneWire:=nil;
      exit;
    end;
    if Assigned(FOnEnabled) then
      FOnEnabled(self);
  end
  else  // disable
  begin
    if Assigned(FOnDisabled) then
      FOnDisabled(self);
    FFirmataBoard.FirmataOneWire:=nil;  // free onewire pin
    if Assigned(FFirmataBoard) then
      FFirmataBoard.FirmataOneWire:=nil;
    FEnabled:=False;
  end;
end;

function TFirmataOneWire.GetNextByte: Byte;
begin
   Result:=FFirmataBoard.GetNextByte;
end;

procedure TFirmataOneWire.GetFirmataCommand(Sender: TObject; Command: Byte);
var
  Pin: byte;
  ReadByte: Byte;
  DataString: string;
  OneWireIDs: array of string;
  i: integer;
begin
  DataString:='';
  case Command of
       {0  START_SYSEX      (0xF0)
       1  OneWire Command  (0x73)
       2  search reply command (0x42|0x45) 0x42 normal search reply
                                           0x45 reply to a SEARCH_ALARMS request
       3  pin              (0-127)
       4  bit 0-6   [optional] address bytes encoded using 8 times 7 bit for 7 bytes of 8 bit
       5  bit 7-13  [optional] 1.address[0] = byte[0]    + byte[1]<<7 & 0x7F
       6  bit 14-20 [optional] 1.address[1] = byte[1]>>1 + byte[2]<<6 & 0x7F
       7  ....                 ...
       11 bit 49-55            1.address[6] = byte[6]>>6 + byte[7]<<1 & 0x7F
       12 bit 56-63            1.address[7] = byte[8]    + byte[9]<<7 & 0x7F
       13 bit 64-69            2.address[0] = byte[9]>>1 + byte[10]<<6 &0x7F
       n  ... as many bytes as needed (don't exceed MAX_DATA_BYTES though)
       n+1  END_SYSEX      (0xF7)}
       ONEWIRE_SEARCH_REPLY, ONEWIRE_SEARCH_ALARMS_REPLY: begin  // $42 $45
          Pin:=GetNextByte;
          ReadByte:=GetNextByte;
          while ReadByte <> END_SYSEX do
          begin
             DataString:=DataString+chr(ReadByte); // less significative byte first
             ReadByte:=GetNextByte
          end;
          DataString:=FFirmataBoard.Decode7To8bit(DataString);

          SetLength(OneWireIDs,Length(DataString) div 8);  // Calc size of discovered IDs array
          for i:=0 to length(OneWireIDs)-1 do // fill the array
            OneWireIDs[i]:=Copy(DataString,i,8);  // Store next ID

          if Command = ONEWIRE_SEARCH_REPLY then
          begin
            if Assigned(FOnOneWireSearch) then
              FOnOneWireSearch(self,pin,OneWireIDs);
          end
          else  // ONEWIRE_SEARCH_ALARMS_REPLY
             if Assigned(FOnOneWireAlarm) then
               FOnOneWireAlarm(self,pin,OneWireIDs);
       end;
       {0  START_SYSEX          (0xF0)
       1  OneWire Command      (0x73)
       2  read reply command   (0x43)
       3  pin                  (0-127)
       4  bit 0-6   [optional] data bytes encoded using 8 times 7 bit for 7 bytes of 8 bit
       5  bit 7-13  [optional] correlationid[0] = byte[0]   + byte[1]<<7 & 0x7F
       6  bit 14-20 [optional] correlationid[1] = byte[1]>1 + byte[2]<<6 & 0x7F
       7  bit 21-27 [optional] data[0] = byte[2]>2 + byte[3]<<5 & 0x7F
       8  ....                 data[1] = byte[3]>3 + byte[4]<<4 & 0x7F
       n  ... as many bytes as needed (don't exceed MAX_DATA_BYTES though)
       n+1  END_SYSEX          (0xF7)}
       ONEWIRE_READ_REPLY: begin //  $43;
           Pin:=GetNextByte;
           ReadByte:=GetNextByte;
           while ReadByte <> END_SYSEX do
           begin
              DataString:=DataString+chr(ReadByte); // less significative byte first
              ReadByte:=GetNextByte;
           end;
           DataString:=FFirmataBoard.Decode7To8bit(DataString); // Data received from Onewire
           if Assigned(FOnOneWireData) then
             // object, onewirepin, data (correlation and scratchpad)
             FOnOneWireData(self,pin,DataString);
       end
       else   // Onwrire command unknown
       begin   // unknown OneWire command, now read until end command
         ReadByte:=GetNextByte;
         while ReadByte <> END_SYSEX do
         begin
           DataString:=DataString+chr(ReadByte);
           ReadByte:=GetNextByte;
         end;
         FFirmataBoard.comException(4, 'GetOneWireCommands', Command);
       end;
   end;
end;

//
// ONEWIRE commands
//

{0  START_SYSEX      (0xF0)
1  OneWire Command  (0x73)
2  config command   (0x41)
3  pin              (0-127)
4  power            (0x00|0x01) 0x00 = leave pin on state high after write to support
                                parasitic power
                                0x01 = don't leave pin on high after write
5  END_SYSEX (0xF7)}
function TFirmataOneWire.OnewireConfig(Pin: Byte; ParasitisticPower: Boolean; write: Boolean=true): string;
var
   Value: Byte;
begin
  if ParasitisticPower then
    Value:=1
  else
    Value:=0;
  FFirmataBoard.FPins[Pin and $7F].ActualMode:=PIN_MODE_ONEWIRE;
  Result:=FFirmataBoard.SendSysEx(chr(ONEWIRE_DATA)+chr(ONEWIRE_CONFIG_REQUEST)+chr(Pin and $7F)+chr(Value), write);
end;

{0  START_SYSEX      (0xF0)
 1  OneWire Command  (0x73)
 2  search command   (0x40|0x44) 0x40 normal search for all devices on the bus
                        0x44 SEARCH_ALARMS request to find only those
                        devices that are in alarmed state.
 3  pin              (0-127)
 4  END_SYSEX        (0xF7)}
function TFirmataOneWire.OnewireSearch(Pin: Byte; write: Boolean=true): string;
begin
  Result:=FFirmataBoard.SendSysEx(chr(ONEWIRE_DATA)+chr(ONEWIRE_SEARCH_REQUEST)+chr(Pin and $7F), write);
end;
{0  START_SYSEX      (0xF0)
1  OneWire Command  (0x73)
2  search command   (0x40|0x44) 0x40 normal search for all devices on the bus
                                0x44 SEARCH_ALARMS request to find only those
                                devices that are in alarmed state.
3  pin              (0-127)
4  END_SYSEX        (0xF7) }
function TFirmataOneWire.OnewireAlarmSearch(Pin: Byte; write: Boolean=true): string;
begin
  Result:=FFirmataBoard.SendSysEx(chr(ONEWIRE_DATA)+chr(ONEWIRE_SEARCH_ALARMS_REQUEST)+chr(Pin and $7F), write);
end;

{0  START_SYSEX      (0xF0)
1  OneWire Command  (0x73)
2  command bits     (0x00-0x2F) bit 0 = reset, bit 1 = skip, bit 2 = select,
                                bit 3 = read, bit 4 = delay, bit 5 = write
3  pin              (0-127)
4  bit 0-6   [optional] data bytes encoded using 8 times 7 bit for 7 bytes of 8 bit
5  bit 7-13  [optional] data[0] = byte[0]   + byte[1]<<7 & 0x7F
6  bit 14-20 [optional] data[1] = byte[1]>1 + byte[2]<<6 & 0x7F
7  ....                 data[2] = byte = byte[2]>2 + byte[3]<<5 & 0x7F ...
n  ... as many bytes as needed (don't exceed MAX_DATA_BYTES though)
n+1  END_SYSEX      (0xF7)

// data bytes within OneWire Request Command message
0  address[0]                    [optional, if bit 2 set]
1  address[1]                              "
2  address[2]                              "
3  address[3]                              "
4  address[4]                              "
5  address[5]                              "
6  address[6]                              "
7  address[7]                              "
8  number of bytes to read (LSB) [optional, if bit 3 set]
9  number of bytes to read (MSB)           "
10 request correlationid byte 0            "
11 request correlationid byte 1            "
10 delay in ms      (bits 0-7)   [optional, if bit 4 set]
11 delay in ms      (bits 8-15)            "
12 delay in ms      (bits 16-23)           "
13 delay in ms      (bits 24-31)           "
14 data to write    (bits 0-7)   [optional, if bit 5 set]
15 data to write    (bits 8-15)            "
16 data to write    (bits 16-23)           "
n  ... as many bytes as needed (don't exceed MAX_DATA_BYTES though)}
function TFirmataOneWire.SendOnewireCommands(Command: Byte; Pin: Byte; Device: String;
     numBytesToRead: uint16; correlationId: uint16; delay: integer; dataToWrite: String; write: Boolean=true): string;
var
   Data8bit: string;
   SubCommand: byte;
begin
  Data8bit:='';
  Subcommand:=Command;

  if Device<>'' then
  begin
    SubCommand:=Subcommand or ONEWIRE_SELECT_REQUEST_BIT;
    // Device
    Data8bit:=Data8bit+leftStr(Device+'#0#0#0#0#0#0#0#0',8);  // set length to 8 and fill with #0
  end;
  if (numBytesToRead<>0) or (CorrelationId<>0) then
  begin
    SubCommand:=Subcommand or ONEWIRE_READ_REQUEST_BIT;
    Data8bit:=Data8bit+chr(numBytesToRead and $FF)+chr((numBytesToRead >> 8) and $FF);
    Data8bit:=Data8bit+chr(correlationId and $FF)+chr((correlationId >> 8) and $FF);
  end;
  if delay<>0 then
  begin
    SubCommand:=Subcommand or ONEWIRE_DELAY_REQUEST_BIT;
    Data8bit:=Data8bit+chr(delay and $FF)+chr((delay >> 8) and $FF)+chr((delay >> 16) and $FF)+chr((delay >> 24) and $FF);
  end;

  Result:=FFirmataBoard.SendSysEx(chr(ONEWIRE_DATA)+chr(Subcommand)+chr(Pin and $7F)+FFirmataBoard.Encode8To7Bit(Data8Bit+dataToWrite), write);
end;

function TFirmataOneWire.OnewireReset(Pin: Byte; write: Boolean=true): string;
begin
  //Command, Pin, Device, numBytesToRead, correlationId, delay, dataToWrite, write
  Result:=SendOnewireCommands(ONEWIRE_RESET_REQUEST_BIT, Pin, '', 0, 0, 0, '', write);
end;

function TFirmataOneWire.OnewireSkip(Pin: Byte; write: Boolean=true): string;
begin
  //Command, Pin, Device, numBytesToRead, correlationId, delay, dataToWrite, write
  Result:=SendOnewireCommands(ONEWIRE_SKIP_REQUEST_BIT, Pin, '', 0, 0, 0, '', write);
end;

function TFirmataOneWire.OnewireSelect(Pin: Byte; Device: string; write: Boolean=true): string;
begin
  //Command, Pin, Device, numBytesToRead, correlationId, delay, dataToWrite, write
  Result:=SendOnewireCommands(ONEWIRE_SELECT_REQUEST_BIT, Pin, Device, 0, 0, 0, '', write);
end;

function TFirmataOneWire.OnewireResetAndSelect(Pin: Byte; Device: string; write: Boolean=true): string;
begin
  //Command, Pin, Device, numBytesToRead, correlationId, delay, dataToWrite, write
  Result:=SendOnewireCommands(ONEWIRE_RESET_REQUEST_BIT or ONEWIRE_SELECT_REQUEST_BIT, Pin, Device, 0, 0, 0, '', write);
end;

function TFirmataOneWire.OnewireRead(Pin: Byte; BytestoRead: uint16; Correlation: uint16; write: Boolean=true): string;
begin
  //Command, Pin, Device, numBytesToRead, correlationId, delay, dataToWrite, write
  Result:=SendOnewireCommands(ONEWIRE_READ_REQUEST_BIT, Pin, '', BytestoRead, correlation, 0, '', write);
end;

function TFirmataOneWire.OneWireDelay(Pin: Byte; Delay: integer; write: Boolean=true): string;
begin
  //Command, Pin, Device, numBytesToRead, correlationId, delay, dataToWrite, write
  Result:=SendOnewireCommands(ONEWIRE_DELAY_REQUEST_BIT, Pin, '', 0, 0, Delay, '', write);
end;

function TFirmataOneWire.OneWireWrite(Pin: Byte; Data: string; write: Boolean=true): string;
begin
  //Command, Pin, Device, numBytesToRead, correlationId, delay, dataToWrite, write
  Result:=SendOnewireCommands(ONEWIRE_WRITE_REQUEST_BIT, Pin, '', 0, 0, 0, Data, write);
end;

function TFirmataOneWire.OnewireWrite(Pin: Byte; Delay: integer; Data: string; write: Boolean=true): string;  overload;
begin
  Result:=SendOnewireCommands(ONEWIRE_WRITE_REQUEST_BIT, Pin, '', 0, 0, Delay, Data, write);
end;

function TFirmataOneWire.OnewireWriteAndRead(Pin: Byte; BytestoRead: uint16; Correlation: uint16; Data: string; write: Boolean=true): string;
begin
  //Command, Pin, Device, numBytesToRead, correlationId, delay, dataToWrite, write
  Result:=SendOnewireCommands(ONEWIRE_WRITE_REQUEST_BIT or ONEWIRE_READ_REQUEST_BIT, Pin, '',
                   BytestoRead, Correlation, 0, Data, write);
end;

function TFirmataOneWire.OnewireWriteAndRead(Pin: Byte; BytestoRead: uint16; Correlation: uint16; Delay: integer; Data: string; write: Boolean=true): string; overload;
begin
  //Command, Pin, Device, numBytesToRead, correlationId, delay, dataToWrite, write
  Result:=SendOnewireCommands(ONEWIRE_WRITE_REQUEST_BIT or ONEWIRE_READ_REQUEST_BIT, Pin, '',
                   BytestoRead, Correlation, Delay, Data, write);
end;

// Returns CRC8 of a string
function TFirmataOneWire.InternalCRC8(Buffer: String): Byte;
var
  i_Byte, j_Bit: Byte;
begin
  Result:=0;

  for i_Byte:=1 to Length(Buffer) do
  begin
    Result:=Result xor ord(Buffer[i_Byte]);
    for j_Bit:=1 to 8 do
    begin
      if (Result and 1 ) = 1 then
        Result:=(Result shr 1) xor $8C
      else
        Result:=Result shr 1;
    end;
  end;
end;

// Returns CRC16 of a string
function TFirmataOneWire.InternalCRC16(Buffer: String): uint16;
var
  i_Byte, j_Bit: Byte;
begin
  Result:=0;

  for i_Byte:=1 to Length(Buffer) do
  begin
    Result:=Result xor ord(Buffer[i_Byte]);
    for j_Bit:=1 to 8 do
    begin
      if (Result and 1 ) = 1 then
        Result:=(Result shr 1) xor $A001
      else
        Result:=Result shr 1;
    end;
  end;
end;

// Ckeck CRC8, of a string last byte is CRC, returns true o false
function TFirmataOneWire.CheckCRC8(Buffer: string): Boolean;
begin
  if (Length(Buffer) < 2) then  // two bytes min, a byte and CRC
  begin
    Result:=False;
    exit;
  end;

  Result:=InternalCRC8(LeftStr(Buffer,Length(Buffer)-1)) = ord(Buffer[Length(Buffer)]);
end;

// Ckeck CRC16, of a string last 2 bytes is CRC, returns true o false
function TFirmataOneWire.CheckCRC16(Buffer: String): Boolean;
begin
  if (Length(Buffer) < 3) then  // three bytes min, a byte and 2 bytes CRC
  begin
    Result:=False;
    exit;
  end;

  Result:=InternalCRC16(LeftStr(Buffer,Length(Buffer)-2)) = Puint16(@Buffer[Length(Buffer)-1])^;
end;
//
//
//
{ TFirmataI2C }
//
//
//
constructor TFirmataI2C.Create(AOwner: TComponent);
begin
  inherited;

  FFirmataBoard:= nil;
  FEnabled:=false;

  FOnEnabled:=nil;
  FOnDisabled:=nil;

  FOnI2CData:=nil;
  FI2CQueries:=0;
  FI2Cconfig:='';  // initial configuration string
  FDelay:=0;  // default delay is 0
  FSDAPin:=18;  // default SDA pin is 18, A4
  FSCLPin:=19;     // deafult SCL pin is 19, A5
end;

destructor TFirmataI2C.Destroy();
begin
  inherited Destroy;
end;

procedure TFirmataI2C.setFirmataBoard(Board: TFirmataBoard);
begin
  if Assigned(Board) then
    FFirmataBoard:=Board;
end;

procedure TFirmataI2C.setSDAPin(SDApin: Byte);
begin
  if FEnabled then
  begin
    FFirmataBoard.comException(33, 'setSDAPin');
    exit;
  end;
  FSDAPin:=SDAPin
end;

procedure TFirmataI2C.setSCLPin(SCLpin: Byte);
begin
  if FEnabled then
  begin
    FFirmataBoard.comException(33, 'setSCLPin');
    exit;
  end;
  FSCLPin:=SCLPin
end;

procedure TFirmataI2C.setEnabled(State: Boolean);
begin
  if not Assigned(FFirmataBoard) then
    exit;

  if FEnabled = State then
     exit;

  if State then
  begin
    FEnabled:=False;
    if Assigned(FFirmataBoard) and FFirmataBoard.Enabled then
    begin
      FFirmataBoard.FirmataI2C:=self;
      if (FSDAPin <> PIN_MODE_IGNORE) and (FSCLPin <> PIN_MODE_IGNORE) then
      begin
        if Assigned(FFirmataBoard.Pins[FSDAPin].Busy) then
        begin
          FFirmataBoard.comException(12, 'setEnabled', FSDAPin);
          exit;
        end
        else if Assigned(FFirmataBoard.Pins[FSCLPin].Busy) then
        begin
          FFirmataBoard.comException(12, 'setEnabled', FSCLPin);
          exit;
        end
        else // Both pis are free
        begin // Configure I2C
          i2cconfig(FDelay, FI2Cconfig);
          FEnabled:=true;
          if Assigned(FOnDisabled) then
            FOnDisabled(self);
        end;
      end
      else  // No valid pins
        FFirmataBoard.comException(7, 'setEnabled');
    end
    else  // firmata is not enabled
    begin
      FFirmataBoard.comException(36, 'setEnabled');
    end;
  end
  else  // state is false disable
  begin
    if Assigned(FOnDisabled) then
      FOnDisabled(self);
    FFirmataBoard.FPins[FSDAPin].Busy:=nil;   // free pins
    FFirmataBoard.FPins[FSCLPin].Busy:=nil;
    if Assigned(FFirmataBoard) then
      FFirmataBoard.FirmataI2C:=nil;
    FEnabled:=False;
  end;
end;

function TFirmataI2C.GetNextByte: Byte;
begin
   Result:=FFirmataBoard.GetNextByte;
end;

procedure TFirmataI2C.GetFirmataCommand(Sender: TObject);
var
  ReadByte: Byte;
  DataString: string;
  Slave_Address : byte;
  I2C_Register: byte;
begin
  DataString:='';
  {0  START_SYSEX (0xF0)
   1  I2C_REPLY (0x77)
   2  slave address (LSB)
   3  slave address (MSB)
   4  register (LSB)
   5  register (MSB)
   6  data 0 (LSB)
   7  data 0 (MSB)
   ...
   n  END_SYSEX (0XF7)}
   Slave_Address:=GetNextByte or (GetNextByte << 7);
   I2C_Register:=GetNextByte or (GetNextByte << 7);
   ReadByte:=GetNextByte;
   while ReadByte <> END_SYSEX do  // Read Data string each data byte are 2 bytes (low byte, high byte)
   begin
     DataString:=DataString+Char(ReadByte);
     ReadByte:=GetNextByte;
   end;
   DataString:=FFirmataBoard.Decode2BytesCharTo1(DataString);
   if Assigned(FOnI2CData) then
      FOnI2CData(self, Slave_Address, I2C_Register, DataString);
end;
//
// ONEWIRE commands
//
{0  START_SYSEX (0xF0)
1  I2C_CONFIG (0x78)
2  Delay in microseconds (LSB) [optional]
3  Delay in microseconds (MSB) [optional]
... user defined for special cases, etc
n  END_SYSEX (0xF7)}
function TFirmataI2C.i2cConfig(Delay: byte; Data: String; write: Boolean=True): string; overload;
var
  I2CData: string;
begin
  Result:='';
  I2CData:='';
  if Delay > 0 then
    I2CData:=chr(Delay and $7F)+chr(Delay >> 7);

  // Not sure what to do with 'Data', in normal use is always null
  if Data <> '' then
    I2CData:=I2CData+FFirmataBoard.Encode8To7Bit(Data); // not sure if this is the right conversion, perhaps 1ByteCharTo2 function

  // Firmata defaults pins, set pin 18 y 19 (analog 4 and 5) to I2c Mode  SDA, SCL
  if FFirmataBoard.FPins[FSDAPin].ActualMode <> PIN_MODE_I2C then
    FFirmataBoard.setPinMode(FSDAPin, PIN_MODE_I2C);  // SDA pin
  if FFirmataBoard.FPins[FSCLPin].ActualMode <> PIN_MODE_I2C then
    FFirmataBoard.setPinMode(FSCLPin, PIN_MODE_I2C);  // SCL pin

  Result:=FFirmataBoard.SendSysEx(chr(I2C_CONFIG)+I2CData, write);
end;

function TFirmataI2C.i2cConfig(write: Boolean=true): string; overload;
begin
  Result:=i2cConfig(0, '', write);
end;

function TFirmataI2C.i2cConfig(Data: string; write: Boolean=True): string; overload;  // No delay
begin
  Result:=i2cConfig(0, Data, write);
end;

function TFirmataI2C.i2cConfig(Delay: byte; write: Boolean=True): string; overload;  // delay
begin
  Result:=i2cConfig(Delay, '', write);
end;

{0  START_SYSEX (0xF0)
1  I2C_REQUEST (0x76)
2  slave address (LSB)
3  slave address (MSB) + read/write and address mode bits
          bit 7: always 0
          bit 6: auto restart transmission, 0 = stop (default), 1 = restart
          bit 5: address mode, 0 = 7bits mode, 1 = 10-bit mode
          bits 4-3: read/write, 00 = write, 01 = read once, 10 = read continuously, 11 = stop reading
          bits 2-0: slave address MSB in 10-bit mode, not used in 7-bit mode
4  data 0 (LSB)
5  data 0 (MSB)
6  data 1 (LSB)
7  data 1 (MSB)
...
n  END_SYSEX (0xF7) }
function TFirmataI2C.i2cRequest(Slave: word; command: byte; data: string; restart: Boolean=false; mode10bit: boolean=false; write: Boolean=True): string;
var
  I2CData: string;
  Mode: Byte;   // is slave address (MSB) + bits
begin
  Mode:=command and I2C_READ_WRITE_MODE_MASK; // only keeps bits 4 and 3
  if mode10bit then
  begin
     Mode:=Mode or ((Slave >> 7) and 7); // takes bits 7,8 and 9 from slave ¿?
     Mode:=Mode or I2C_10BIT_ADDRESS_MODE_MASK;  // set 10 bit mode, bit 5 on
  end;

  if restart then
    Mode:=Mode or I2C_AUTORESTART_RESTART;   // bit 6 on

  {bits 4-3: read/write, 00 = write, 01 = read once, 10 = read continuously, 11 = stop reading}
  {case (command and I2C_READ_WRITE_MODE_MASK) of
     I2C_WRITE:begin
        ;
     end;
     I2C_READ: begin
         // a slave register is specified
         // slaveRegister = data[1] + (data[2] << 7);
         // data[3] or (data[4] << 7) = bytes to read
         // else
         // data[1] or (data[2] << 7) = bytes to read
     end;
     I2C_READ_CONTINUOUSLY: begin
         // if a slave register is specified
         // slaveRegister = data[1] + (data[2] << 7);
         // data[3] or (data[4] << 7) = bytes to read
         // else
         // data[1] or (data[2] << 7) = bytes to read
     end;
     I2C_STOP_READING: begin

     end;
  end; }

  I2CData:=FFirmataBoard.Encode1ByteCharTo2(Data);

  Result:=FFirmataBoard.SendSysEx(chr(I2C_REQUEST)+chr(Slave and $7F)+chr(Mode)+I2CData, write);
end;

function TFirmataI2C.i2cWrite(Slave: Byte; Address: integer; AddressSize: Byte; Data: String; restart: Boolean=false; write: Boolean=True): string;
  //i2cRequest(Slave, command, data, restart, mode10bit, write)
var
  I2CData: string;
begin
  Result:='';

  I2CData:=chr(Address and $FF);
  if AddressSize = 2 then
    I2CData:=chr((Address >> 8) and $FF)+I2CData;   // first is MSB byte address

  if ((Length(Data)+Length(I2CData)) * 2) > (MAX_DATA_BYTES - 5) then // because each byte needs two bytes in messsage
  begin
    FFirmataBoard.comException(30, 'i2cWrite', Length(Data)+Length(I2CData));
    exit;
  end;

  Result:=i2cRequest(Slave, I2C_WRITE, I2CData+Data, restart, false, write);
end;

function TFirmataI2C.i2cRead(Slave: Byte; regID: integer; BytesToRead: byte;
                 restart: Boolean=false; write: Boolean=True): string;
//i2cRequest(Slave, command, data, restart, mode10bit, write)
var
  I2CData: string;
begin
  Result:='';

  if RegID <> -1 then
    I2CData:=chr(RegID and $7F)+chr(BytesToRead)
  else
    I2CData:=chr(BytesToRead);

  if ((Length(I2CData)+BytesToRead) * 2) > (MAX_DATA_BYTES - 5) then // because each byte needs two bytes in messsage
  begin
    FFirmataBoard.comException(29, 'i2cRead', Length(I2CData)+BytesToRead);
    exit;
  end;
  Result:=i2cRequest(Slave, I2C_READ, I2CData, restart, false, write);
end;

function TFirmataI2C.i2cRandomRead(Slave: Byte; Address: word; AddressSize: Byte; BytesToRead: byte;
                 restart: Boolean=false; write: Boolean=True): string;
//i2cRequest(Slave, command, data, restart, mode10bit, write)
begin
  Result:='';
  if ((BytesToRead + 1) * 2) > (MAX_DATA_BYTES - 5) then // because each byte needs two bytes in messsage
  begin
    FFirmataBoard.comException(29, 'i2cRandomRead', BytesToRead + 1);
    exit;
  end;
  // Dummy write, select address
  Result:=i2cWrite(Slave, Address, AddressSize, '', restart, write);
  // Real read
  Result:=Result+i2cRequest(Slave, I2C_READ, chr(BytesToRead), restart, false, write);
end;

function TFirmataI2C.i2cReadContinuosly(Slave: Byte; RegID: integer; BytesToRead: byte; restart: Boolean=false; write: Boolean=True): string;
//i2cRequest(Slave, command, data, restart, mode10bit, write)
var
  I2CData: string;
begin
  Result:='';

  if RegID <> -1 then
    I2CData:=chr(RegID and $7F)+chr(BytesToRead)
  else
    I2CData:=chr(BytesToRead);

  if ((Length(I2CData)+BytesToRead) * 2) > (MAX_DATA_BYTES - 5) then // because each byte needs two bytes in messsage
  begin
    FFirmataBoard.comException(29, 'i2cReadContinuosly', Length(I2CData)+BytesToRead);
    exit;
  end;
  Result:=i2cRequest(Slave, I2C_READ_CONTINUOUSLY, I2CData, restart, false, write);
end;

function TFirmataI2C.i2cStopReading(Slave: Byte; write: Boolean=True): string;
//i2cRequest(Slave, command, data, restart, mode10bit, write)
begin
  Result:=i2cRequest(Slave, I2C_STOP_READING, '', false, false, write);
end;

function TFirmataI2C.i2cWrite10Bits(Slave: uint16; Address: integer; AddressSize: Byte; Data: String; restart: Boolean=false; write: Boolean=True): string;
  //i2cRequest(Slave, command, data, restart, mode10bit, write)
var
  I2CData: string;
begin
  Result:='';

  I2CData:=chr(Address and $FF);
  if AddressSize = 2 then
    I2CData:=chr((Address >> 8) and $FF)+I2CData;   // first is MSB byte address

  if ((Length(Data)+Length(I2CData)) * 2) > (MAX_DATA_BYTES - 5) then // because each byte needs two bytes in messsage
  begin
    FFirmataBoard.comException(30, 'i2cWrite10Bits', Length(Data)+Length(I2CData));
    exit;
  end;
  Result:=i2cRequest(Slave, I2C_WRITE, I2CData+Data, restart, true, write);
end;

function TFirmataI2C.i2cRead10bits(Slave: uint16; regID: integer; BytesToRead: byte; restart: Boolean=false; write: Boolean=True): string;
var
  I2CData: string;
begin
  Result:='';

  if RegID <> -1 then
    I2CData:=chr(RegID and $7F)+chr(BytesToRead)
  else
    I2CData:=chr(BytesToRead);

  if ((Length(I2CData)+BytesToRead) * 2) > (MAX_DATA_BYTES - 5) then // because each byte needs two bytes in messsage
  begin
    FFirmataBoard.comException(29, 'i2cRead10Bits', Length(I2CData)+BytesToRead);
    exit;
  end;
  Result:=Result+i2cRequest(Slave, I2C_READ, I2CData, restart, true, write);
end;

function TFirmataI2C.i2cRandomRead10bits(Slave: Byte; Address: word; AddressSize: Byte; BytesToRead: byte;
                 restart: Boolean=false; write: Boolean=True): string;
begin
  Result:='';

  if ((BytesToRead + 1) * 2) > (MAX_DATA_BYTES - 5) then // because each byte needs two bytes in messsage
  begin
    FFirmataBoard.comException(29, 'i2cRandomRead10Bits', BytesToRead + 1);
    exit;
  end;
  // Dummy write, select address
  Result:=i2cWrite10Bits(Slave, Address, AddressSize, '', restart, write);
  // Real read
  Result:=Result+i2cRequest(Slave, I2C_READ, chr(BytesToRead), restart, True, write);
end;

function TFirmataI2C.i2cRead10bitsContinuosly(Slave: uint16; RegID: integer; BytesToRead: byte;
                 restart: Boolean=false; write: Boolean=True): string;
//i2cRequest(Slave, command, data, restart, mode10bit, write)
var
  I2CData: string;
begin
  Result:='';

  if RegID <> -1 then
    I2CData:=chr(RegID and $7F)+chr(BytesToRead)
  else
    I2CData:=chr(BytesToRead);

  if ((Length(I2CData)+BytesToRead) * 2) > (MAX_DATA_BYTES - 5) then // because each byte needs two bytes in messsage
  begin
    FFirmataBoard.comException(29, 'i2cRead10Bits', Length(I2CData)+BytesToRead);
    exit;
  end;
  Result:=i2cRequest(Slave, I2C_READ_CONTINUOUSLY, I2CData, restart, True, write);
end;

function TFirmataI2C.i2cStopReading10bits(Slave: uint16; write: Boolean=True): string;
//i2cRequest(Slave, command, data, restart, mode10bit, write)
begin
  Result:=i2cRequest(Slave, I2C_STOP_READING, '', false, True, write);
end;

end.


